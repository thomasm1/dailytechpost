web3.eth.Contract
The web3.eth.Contract object makes it easy to interact with smart contracts on the ethereum blockchain. When you create a new contract object you give it the json interface of the respective smart contract and web3 will auto convert all calls into low level ABI calls over RPC for you.

This allows you to interact with smart contracts as if they were JavaScript objects.

To use it standalone:

new contract
new web3.eth.Contract(jsonInterface[, address][, options])
Creates a new contract instance with all its methods and events defined in its json interface object.

Parameters
jsonInterface - Object: The json interface for the contract to instantiate
address - String (optional): The address of the smart contract to call, can be added later using myContract.options.address = '0x1234..'
options - Object (optional): The options of the contract. Some are used as fallbacks for calls and transactions:
from - String: The address transactions should be made from.
gasPrice - String: The gas price in wei to use for transactions.
gas - Number: The maximum gas provided for a transaction (gas limit).
data - String: The byte code of the contract. Used when the contract gets deployed.
Returns
Object: The contract instance with all its methods and events.

Example
var myContract = new web3.eth.Contract([...], '0xde0B295669a9FD93d5F28D9Ec85E40f4cb697BAe', {
    from: '0x1234567890123456789012345678901234567891', // default from address
    gasPrice: '20000000000' // default gas price in wei, 20 gwei in this case
});
= Properties =
options
myContract.options
The options object for the contract instance. from, gas and gasPrice are used as fallback values when sending transactions.

Properties
Object - options:

address - String: The address where the contract is deployed. See options.address.
jsonInterface - Array: The json interface of the contract. See options.jsonInterface.
data - String: The byte code of the contract. Used when the contract gets deployed.
from - String: The address transactions should be made from.
gasPrice - String: The gas price in wei to use for transactions.
gas - Number: The maximum gas provided for a transaction (gas limit).
Example
myContract.options;
> {
    address: '0x1234567890123456789012345678901234567891',
    jsonInterface: [...],
    from: '0xde0B295669a9FD93d5F28D9Ec85E40f4cb697BAe',
    gasPrice: '10000000000000',
    gas: 1000000
}

myContract.options.from = '0x1234567890123456789012345678901234567891'; // default from address
myContract.options.gasPrice = '20000000000000'; // default gas price in wei
myContract.options.gas = 5000000; // provide as fallback always 5M gas
options.address
myContract.options.address
The address used for this contract instance. All transactions generated by web3.js from this contract will contain this address as the “to”.

The address will be stored in lowercase.

Property
address - String|null: The address for this contract, or null if it’s not yet set.

Example
myContract.options.address;
> '0xde0b295669a9fd93d5f28d9ec85e40f4cb697bae'

// set a new address
myContract.options.address = '0x1234FFDD...';
options.jsonInterface
myContract.options.jsonInterface
The json interface object derived from the ABI of this contract.

Property
jsonInterface - Array: The json interface for this contract. Re-setting this will regenerate the methods and events of the contract instance.

Example
myContract.options.jsonInterface;
> [{
    "type":"function",
    "name":"foo",
    "inputs": [{"name":"a","type":"uint256"}],
    "outputs": [{"name":"b","type":"address"}]
},{
    "type":"event",
    "name":"Event"
    "inputs": [{"name":"a","type":"uint256","indexed":true},{"name":"b","type":"bytes32","indexed":false}],
}]

// set a new interface
myContract.options.jsonInterface = [...];
= Methods =
clone
myContract.clone()
Clones the current contract instance.

Parameters
none

Returns
Object: The new contract instance.

Example
var contract1 = new eth.Contract(abi, address, {gasPrice: '12345678', from: fromAddress});

var contract2 = contract1.clone();
contract2.options.address = address2;

(contract1.options.address !== contract2.options.address);
> true
deploy
myContract.deploy(options)
Call this function to deploy the contract to the blockchain. After successful deployment the promise will resolve with a new contract instance.

Parameters
options - Object: The options used for deployment.
data - String: The byte code of the contract.
arguments - Array (optional): The arguments which get passed to the constructor on deployment.
Returns
Object: The transaction object:

Array - arguments: The arguments passed to the method before. They can be changed.
Function - send: Will deploy the contract. The promise will resolve with the new contract instance, instead of the receipt!
Function - estimateGas: Will estimate the gas used for deploying.
Function - encodeABI: Encodes the ABI of the deployment, which is contract data + constructor parameters
For details to the methods see the documentation below.
Example
myContract.deploy({
    data: '0x12345...',
    arguments: [123, 'My String']
})
.send({
    from: '0x1234567890123456789012345678901234567891',
    gas: 1500000,
    gasPrice: '30000000000000'
}, function(error, transactionHash){ ... })
.on('error', function(error){ ... })
.on('transactionHash', function(transactionHash){ ... })
.on('receipt', function(receipt){
   console.log(receipt.contractAddress) // contains the new contract address
})
.on('confirmation', function(confirmationNumber, receipt){ ... })
.then(function(newContractInstance){
    console.log(newContractInstance.options.address) // instance with the new contract address
});


// When the data is already set as an option to the contract itself
myContract.options.data = '0x12345...';

myContract.deploy({
    arguments: [123, 'My String']
})
.send({
    from: '0x1234567890123456789012345678901234567891',
    gas: 1500000,
    gasPrice: '30000000000000'
})
.then(function(newContractInstance){
    console.log(newContractInstance.options.address) // instance with the new contract address
});


// Simply encoding
myContract.deploy({
    data: '0x12345...',
    arguments: [123, 'My String']
})
.encodeABI();
> '0x12345...0000012345678765432'


// Gas estimation
myContract.deploy({
    data: '0x12345...',
    arguments: [123, 'My String']
})
.estimateGas(function(err, gas){
    console.log(gas);
});
methods
myContract.methods.myMethod([param1[, param2[, ...]]])
Creates a transaction object for that method, which then can be called, send, estimated.

The methods of this smart contract are available through:

The name: myContract.methods.myMethod(123)
The name with parameters: myContract.methods['myMethod(uint256)'](123)
The signature: myContract.methods['0x58cf5f10'](123)
This allows calling functions with same name but different parameters from the JavaScript contract object.

Parameters
Parameters of any method depend on the smart contracts methods, defined in the JSON interface.

Returns
Object: The transaction object:

Array - arguments: The arguments passed to the method before. They can be changed.
Function - call: Will call the “constant” method and execute its smart contract method in the EVM without sending a transaction (Can’t alter the smart contract state).
Function - send: Will send a transaction to the smart contract and execute its method (Can alter the smart contract state).
Function - estimateGas: Will estimate the gas used when the method would be executed on chain.
Function - encodeABI: Encodes the ABI for this method. This can be send using a transaction, call the method or passing into another smart contracts method as argument.
For details to the methods see the documentation below.
Example
// calling a method

myContract.methods.myMethod(123).call({from: '0xde0B295669a9FD93d5F28D9Ec85E40f4cb697BAe'}, function(error, result){
    ...
});

// or sending and using a promise
myContract.methods.myMethod(123).send({from: '0xde0B295669a9FD93d5F28D9Ec85E40f4cb697BAe'})
.then(function(receipt){
    // receipt can also be a new contract instance, when coming from a "contract.deploy({...}).send()"
});

// or sending and using the events

myContract.methods.myMethod(123).send({from: '0xde0B295669a9FD93d5F28D9Ec85E40f4cb697BAe'})
.on('transactionHash', function(hash){
    ...
})
.on('receipt', function(receipt){
    ...
})
.on('confirmation', function(confirmationNumber, receipt){
    ...
})
.on('error', console.error);
