Course Overview
Course Overview
Hey everybody. I'm Joe Eames and welcome to my course Building Applications with Angular, Firebase, and AngularFire. I am a developer and conference organizer and I'm super excited to present this course to you. Firebase is a blazing fast, real-time, no SQL backend as a service. Angular is an amazing framework and AngularFire brings the two of them together with a smooth and elegant API. In this course we're going to learn how to build applications with AngularFire by building a real app and seeing how to apply it in a realistic scenario. While we're at it we'll learn real how-to's of using AngularFire in your applications, and also we'll learn all the basics we'll need to use Firebase as well. The major topics we're going to cover are authentication with Firebase, reading & writing list data with the Firebase array service, and reading & writing non list data with the Firebase object service. By the time we're through you'll be confident in hooking up your Angular applications to a Firebase back end. Before starting the course you should be familiar with JavaScript and Angular. Although don't worry, you're not going to have to be an expert. I hope you'll join me on this journey to learn AngularFire with the Building Applications with Angular, Firebase, and AngularFire course at Pluralsight.

Introduction
Welcome
Welcome to Pluralsight's course, "Building Applications with Angular, Firebase, and AngularFire". My name is Joe Eames and it's a pleasure to invite you to come on a journey with me of learning to build applications in Angular and Firebase with AngularFire. Angular 1 is an excellent technology, but only gets better when you incorporate Firebase, and I'm sure you'll agree by the end of this course. There's a lot of reasons to use Firebase with Angular, but the biggest reason that I think you should use them together, is that Firebase is awesome. There's a lot to like about it. It's polished, it's fast, it's cost-effective, but overall it's just a great technology, and AngularFire is just so well-done, it makes developing in Angular even easier and slicker than it already is. Let's take a look at the agenda for this course. First is this introductory section, where we'll learn about the course, its prerequisites, and the demo-app that we'll build as we learn AngularFire. Then we'll dig right into the basics of Firebase, taking a glance at how it works, the admin tools, and some of the more important technical points about it. After that, we'll look at AngularFire specifically; how the Firebase team created a great API for Angular developers. In this section, we'll start building our demo application. Next, we'll get into authentication, and see how easily and simply we can hook up authentication for our users and how to integrate that with routing to protect pages behind login. After that, we'll learn about the Firebase object service, which lets us read and change data in our Firebase. Finally, we'll look at the Firebase Array service, which lets us read and change list data in our Firebase. Now, shortly after this course was finished, AngularFire was updated to version 1.2. There was only a few small changes introduced, and it maintains full backwards compatibility. So after the coverage of the Firebase array, we'll have a short section on taking advantage of the new pieces in 1.2. These pieces mostly deal with how you connect to Firebase, and they aren't very significant, so I didn't bother incorporating them into the rest of the course. In fact, as you'll see in that section, it's debateable as to whether or not they offer any significant advantage. But, overall, the course is completely compatible with version 1.2. There's a lot that this course will teach you. Obviously, you'll learn about AngularFire and Firebase by extension, but this course isn't just about Angularfire. We'll be building a real application, and giving it real functionality. Because of that, we'll see Angular used with Firebase in a large variety of ways. We'll be using Angular 1.5 for this course, which means that you'll learn a lot about the new stuff in this version, especially the new component method, which is a specific kind of directive. So if you're looking for an introduction to Angular 1.5 components, this course will be a great resource. Additionally, we'll be dealing a lot with angular binding, routing, services and other issues, so you'll also just learn a lot about Angular, and hopefully you'll learn to appreciate it even more. I'm really excited to present this course to you, and hope you get a lot out of watching it.

Prerequisites
Since you're spending time watching this course, it's a good idea to understand what you need to know to get the most out of it. You should have a working knowledge of JavaScript. We'll be doing quite a bit with it, and it's good to understand callbacks, context, the "this" object, and other basic JavaScript concepts. Also, you should know HTML, and really, the web in general. A good understanding of how HTML works, how web pages work, and related items will be important. Finally, you should have a decent working knowledge of Angular 1. You don't need to be an expert by any means, but if you'd never worked with it before, this really isn't the course for you. One obvious thing I haven't mentioned is Firebase. For this course, you don't need to know Firebase at all. I will give you all the introduction you will need to use it with your AngularFire projects. Of course, I won't cover it as deeply as it could be covered, so if you want to know more, you can always check out Pluralsight's Firebase fundamentals course.

Course Repository
In order to keep users informed and up to date, I've created a Git Hub repository for this course. The web moves fast, things change all the time, so even though today a course might use the latest technologies, tomorrow it can be a different story. Publishing updates to Pluralsight videos can take a long time, so I'll use this course repo to let you know if anything gets out of date with the course, and how to work around it until I can get the course updated. Thankfully, the technologies used in this course are really good about staying backwards-compatible. So even when new releases come out, it's really unlikely that anything will break, but go ahead and take a minute and check the repo to make sure that the course is up-to-date.

Why You Should Learn Firebase
Firebase is a great technology, and there's quite a few reasons why you should use it in your applications. First, Firebase is an NoSQL data store. That means that it's great for all kinds of applications, and will work for extremely large-scale applications where relational databases can begin to break down. Firebase is proven. It's stable, has lots of users, and can handle large volumes of data. And, perhaps most telling, it's owned by Google. Firebase is real time. It operates over a web socket. That means that changes on the server get pushed down to your application if you're listening to them. This also makes it blazing fast, and, if implemented correctly, it could be much faster than other data storage technologies. But even if you don't need the speed, and you don't have any features that need real time, you will still benefit. Firebase is also great for development. It's well-documented, and accounts for developers are free. Finally, Firebase is versatile. It will work with any front-end. JavaScript, native mobile, even desktop applications can work with Firebase.

The Demo App
The last thing we'll do in this section is look at the demo application that we're going to build in this course. The application that we'll build is a simple expense tracker for your business expenses. Let's look at the finished version. The year is 1985, and you own a little development shop. You've got some expenses, like that new IBMXT you just bought, and other necessary items for business. You need a way to track all of these expenses. That's what this app does. Not only does it let you add and edit expenses, but you can also add new categories for each expense, and set a few user preferences as well. Of course, we protect everything behind login, so the user data is available only to the right user. This is the application we're going to build, and while we do it, we'll learn all about how AngularFire works. Now it's important to realize that this application is built to be realistic, but it's missing a lot of things that a true production application would have. Things like validation, error logging, etc., so keep that in mind as you go through this course. In any case, you'll find a lot to learn if you take the time to follow along and build the application. Your learning will be a lot more complete if you invest the time to learn and practice.

Firebase Basics
Introduction
In this module we're going to look at some of the basics of Firebase. This will be a fairly quick introduction. If you're interested in learning more about these topics my course on the fundamentals of Firebase is a great place to get a deeper look into Firebase itself. I'm going to mention this fact a few times throughout this section, that my course on Firebase has a lot more information. So don't feel like I'm a broken record, there just happens to be a lot of things that we're only going to touch on briefly in this course, that is covered in a lot more depth in my Firebase Fundamentals course. The agenda for this section is as follows, after this introduction we'll look at how to manager a Firebase application, we'll learn the basics of the Management Console, how to manually add and change data and how to navigate around. Then we'll learn how data works and Firebase. Firebase has a few unique things you'll want to learn about how it handles data. Lastly, we'll learn the basics of how Firebase handles security, and the essentials of how you can manager security in your Firebase. It's a good idea to look at a typical architecture for an application that uses Firebase as its data store. Although you can have just a client and Firebase as the backend, with all but the most simple of applications you'll want to have a server. And there will be logic you'll want running on that server and even though most of your data access may be directly between your client and your Firebase, there will definitely be some needs for your server to access Firebase as well. The application we'll build, won't deal at all with the server. But it's not a terribly difficult task to do, once you learn Firebase. One last thing I want to cover in this section is the word Firebase and how it's used. Firebase is often referred to as the service that is provided for users, as in "I'm going to sign up for Firebase". But the way it should be used and the way you'll often hear me use it is as a synonym for a data store in the Firebase service, as in "We'll write that to our Firebase". In this way it's used just like the word database, so keep this in mind.

Firebase Application Management
In this section we'll learn how to use the Firebase Management Console. This the Dashboard which is the first place you see after you login. Firebase is hosted so you will have to login, but creating an account is very easy if you already got a Google account you can simply sign in under that. The Dashboard you see here lists all of the applications that you've created inside of Firebase. Each one of these is its own data store. This is the place where you can go in to manage a specific one or create a new one. Once you've got one created, you simply come over here and click Manage App and you'll move into the Management Console itself for your Firebase. The main tab that you'll be dealing with is the Data tab. This is where you can see all of the data in your Firebase and also create and change that data. Manipulating the data itself is extremely simple. All you need to do is move your mouse over top any piece of data and you'll get these little popup icons that let you do different things. For example you can create a new piece of data, click add, and then if you want to delete it just click the little "X" button and that'll remove it. Also you can drill down into data by clicking on one of these nodes, so if I click on categories, you'll see that the URL has changed and now I'm seeing only the categories node and its pieces of data. If you want to go back, you can navigate back up by clicking up here. Even though you can drill in you'll usually find that it's a lot more convenient to just expand the node that you care about, so if you wanted to look at categories, simply click the plus icon and drilling into the data this way is generally a lot more convenient then navigating into directly. One other thing that's nice to know, is how to save your data and restore it. These two buttons here at the top, allow you to do just that. If you click on Export Data, then it will download a JSON file and if you click on Import Data, it will give you a little popup that lets you choose a JSON file and then import the data which will completely override all the data that you've got, so be careful when doing that. There are other tabs to Firebase we won't need to do too much with them, so we're mostly going to ignore them. Again if you want more information, the Firebase Fundamentals course deals into each one of these in depth. One tab that we will be looking at is the Login and Off tab, but we'll look at it in more detail in our section on authentication.

Data in Firebase
There's a few pieces of information about how Firebase handles data that you'll need to know. First off, data in Firebase is completely based on URL's. So for example, this particular name right here has a URL associated with it, by clicking on it I've navigated to that particular URL, which you can see up here in the top, and that is the URL for this piece of data. At any given URL there is an ID, and the ID is just the last part of the URL. In this case the ID is "name". In this scenario that may not be very useful but if we go up and look at the parent object, this piece of data has an ID that's that big long string starting with a dash. Often times you will need to know the ID of a piece of data when accessing it. Generally this matters when dealing with lists of data such as our list of categories. Each one of these items has an ID associated with it. This brings us to our next point, Firebase does not have the concept of arrays. This is a list of catagories, in JavaScript you would generally use an array to encode this data. Firebase does not have arrays, arrays have an index that is an integer. Firebase essentially stores everything as an object. The categories object has four keys in it. The first two keys are these big long strings starting with dash, the third key is five A's, the forth key is five B's. This is just like property names in a JavaScript object. The reason that Firebase doesn't deal with arrays is because index's can change as you add and delete data. Imagine if instead of these unique keys, we used index's such with the first one was zero, the second one was one, two and then three. If I'm looking at this data and somebody else happens to delete this second node, then all of a sudden what I thought was index two, is now going to shift up and become index one. This can make it essentially impossible to deal with data in this sort of real time scalable environment. That's why Firebase does not use arrays, it uses objects for its data storage. Now this may seem like it's going to be a really big problem when dealing with your application, but the AngularFire Library actually handles this for you and will translate lists of data into arrays on the client side and then back into their native format when it writes them to your Firebase. This is a really great feature so that from the developer's perspective lists of data from Firebase are treated just like any other lists of data that you would deal with. Another piece of information that's important to know is that when you select a piece of data, you are selecting that item and all of its children. So if we select the categories, we are getting not only all the categories but every piece of information that's underneath them. This really makes a difference when it's time to design your data. For example, if you create a list of users and underneath each user you store their expenses, then whenever you just want the list of users you'll also get every users expenses as well. And in a large application that can potentially be a lot of data. So data design matters a lot. Due to this reason, you'll often see the good data design at Firebase involves lots of shallow trees. Going back up to the top, you can see that I've got a route node for categories, one for expenses and one for preferences. These trees are each relatively shallow, and just have the data that they need to do their own job. They don't store a whole bunch of interrelated data. Another important aspect of Firebase's date store is that there are no foreign keys. So for example in our expenses, each expense has a category. We can't link directly to the category, instead I've actually copied both the ID and the name of the category underneath each expense. This sort of data duplication is common in NoSQL scenarios, and we'll see more about this as we build our application in our course. These few pieces of information about how Firebase handles data are going to be important for you to remember as we build applications with Angular and Firebase.

Firebase Security
Security in Firebase is relatively straight forward, but there are a few things you need to know about. First off, every authenticated user in Firebase has a unique ID. It's important to know about this unique ID because this is typically the way that you'll tie a user to their data. It's fairly simple once a user authenticates to ask Firebase in your client side code for that users unique ID, which you can then use to look up and deal with their data. Secondly, Firebase handles authentication for you. In order to access data in Firebase, you'll generally want your users authenticated, and Firebase can do that for you with some very simple tools that are built into the services that AngularFire gives you. Firebase supports a lot of different methods of authentication, anything from anonymous authentication, to typical user name and password. It supports several different OAuth versions, and even a complicated custom version. We'll learn a little bit more about these in our section on authentication. Finally, Firebase has Authorization and Validation rules that you can specify on the server. This is actually great because you can lock down your server and secure it, such that nobody can access data inappropriately. Once you do that, even though your client side may get hacked because client side code ultimately is insecure, nobody can do anything on the server side that you don't allow them to do. So your data will be 100% completely secure, if you lock it down correctly. For more information about this check out my Firebase Fundamentals course, it has an entire section on security.

Summary
In this module we learned about the basics of Firebase, we saw what the Management Console was and how to use it, we learned about how Firebase handles data, and we also learned about how Firebase handles security. This will lay the ground work for us so we can begin to learn how AngularFire specifically adapts Firebase to our Angular applications.

Introduction to AngularFire
Introduction
In this module, we'll get our introduction to AngularFire and start building our application. We'll start with this short introduction then we'll look at how to install AngularFire. There's a few options here. After that, we'll create our demo application and finally, we'll learn how to deal with Firebased Refs in an Angular app. Refs are your connection to your Firebase and we'll learn more about them in a minute. Firebase is a complete, JavaScript API for use with generic, JavaScript applications. AngularFire is an Angular-flavored wrapper around that API. But there is one really important concept that you need to understand. AngularFire does not do all the things that Firebase does. That doesn't mean that you need to learn the Firebase JavaScript library if you are using Angular and AngularFire. In fact, AngularFire does all that you will likely ever need in an Angular application. But the simple fact is there are things that you can do with the lower level API that you can't do with AngularFire so there's still value in learning the lower level API but unless you are seeking a complete understanding of Firebase, you are just fine to learn AngularFire. AngularFire includes three important pieces. Each of these are implemented as Angular services. The first is the $firebaseAuth service. This service lets you deal with authentication in your application. The second is the $firebaseObject service, which lets you read and write data to your Firebase. The final piece is the $firebaseArray service which lets you read and write list-based data to your Firebase. There is one other important piece that you will need to work with and that is Refs. As I mentioned previously, Refs are your connection to Firebase and they point to some data at a specific URL. Each of the AngularFire services listed requires a Ref in order to work. In the case of the $firebaseObject and $firebaseArray, this is what lets you read and write the correct data because the Ref they are given points to the data at the appropriate location. For the $firebaseAuth service, the location the Ref points to isn't important, just so long as it points to the correct Firebase. It's good to understand how these four components interrelate. The three services, $firebaseObject, Array and Auth all come from the AngularFire JavaScript library. The Refs actually come from the Firebase JavaScript library, so when you create them, you'll actually use a global function named Firebase. We'll see that in our application though, so don't worry about needing to memorize this. It's all very simple as you begin working with AngularFire. Now if you're going to follow along with this course, you'll need to create your own Firebase, so make sure you signed up with Firebase, then go into the Dashboard and create yourself an application. Once you've done that, take note of the URL for your application and replace the URL you see in my demo app with your own.

Installation
We're going to get our project started and to do that, I would like to start off with a package.json file. Even if I'm not going to be using Node in the project, or installing any Node dependencies, it's nice to have that file there if I'm going to stick it into Git or whatever or maybe use some simple scripts, it's a great place to store all that stuff. So, of course, I have Node installed. I'm going to type in npm init with a dash Y, which will simply create a package.json file for me with all default answers. I also need a way to run my application. You can use any web server, of course. I like HTTP server. The Node module, I feel like it's simple and easy. There's some other Node TCP servers that are a little more fully featured like Live server with a V and Lite Server with a T. Both of those have some nice features. Of course, you could also just set up a simple ASP.NET server or Java web server or Express Server or whatever you need. But I'm going to use HTTP server, so if you don't have that installed, you can install that with npm install http-server. And it's best to just install it globally with the dash G flag. I've already got it installed, I'm not going to run this command. Next I want to look at my package.json file and adjust it a little bit. I'll go into Visual Studio code and I'll open up that package.json file. I'm going to add in a little description here. I'll say that this is an expense tracker. I'm going to go down into the author field and put in my name and finally, I'm going to make a start script to start this up easily. Since I'm using HTTP server, I won't need any parameters. Just put in that. Really doesn't save me much typing. I'll type in empty and start instead of http-server but it is still nice to have that default option and I don't have to think about it. With that created and saved, the next thing I want to do is to create my index file and I always like to put that inside of a public directory. I'll create a new folder called Public and inside of that, I will create my index.html file. And for this, I'll put in the typical stuff, a doc type, a head, close that up, the body and close with html. Now I want to add four pieces to my application. I want to add Bootstrap first just to make it easy to style up my application, so I'll put in the link and the HREF will be maxcvn. I'm just going to get that from a cvn. The URL, I'll just paste in and that's the URL right there. Finally, I need to add Angular, of course, Firebase and AngularFire. You're going see that I'm using version 1.1.4 of AngularFire but you can go ahead and just type in 1.2.0 instead. Everything will work with the latest version. There's a few ways to add them in to your project. Of course, you could just use a CDM, so I'm going to paste in here the four script files that I need, Angular, Firebase, AngularFire. I've also added AngularRoute right here, but all these are coming from a CDN, so I don't have to worry about hosting them and they'll possibly get served up a lot faster than my servers can, but you may not want to use a CDN. You may want to use these files local. So a common option, of course, is to install them with NPM. Let's go back to our command line. To install them with NPM, you can actually just install AngularFire, and that by itself will install Angular, Firebase and AngularFire because the other two are dependencies on AngularFire. We'll have to also manually install AngularRoute. This is a very decent method, but there's one big problem with using this method and that is the version of Firebase the NPM installs is actually customized to use a Node Module system. We can see that if we go and look at the source file for Firebase. Underneath LIB right here it says Firebase-web and you'd think that since it's -web that it would work for a web project, but if you scroll all the way down to the bottom, you can see right here line 279 is module.exports=Firebase, this will throw an error in our web browser because we're not using any module system in our web browser. We could add to module system but that adds some complexity, so it is going to throw an error. Now, one simple option there is to just go in here and comment out or delete that line and then modify the Firebase.js file. That's one option you can do. The other option is to install Firebase using Bower. If we just do bower install firebase, we'll also need AngularFire and Angular and Angular dash route, and install all of them with Bower. Then if we go and look at the Bower components and Firebase and look at the Firebasejs file and go down to the bottom, you can see there's no module line down here at the bottom, so this file will work just fine inside of our browser. So no matter how you install it, if you're going to bring the file local, you're going to need to make sure that it's accessible. If we collapse these two and look at how we've got our project set up, we'll probably be serving out of this public directory so that'll be the root, in which case, we can't access script files that are up in the Node modules in Bower components folders. So we want to copy the relevant files from those directories and put them in to maybe a vendor folder here under public and the AngularRoute, Firebase and AngularFire files underneath here. Whatever you do you just need to solve these problems. I thinks it's much simpler to just use a CDM, so that's what we're going to do. I'm going to delete this folder and I'll also delete my Node modules and Bower components folder, and we'll just stick with using a CDM. Of course, if you do decide to use Bower and Node, you do want to understand a little bit about how Bower or Node works. You can check out other Pluralsight courses for more information on those. So come back in to here. I'm going to save this file, and we now have the basic set up for an AngularFire project.

Creating the App
Now that we've got our script files set up and our index.html file, we can move on and actually create our Angular application. There's a few pieces to doing this. We start by adding our NG App directive. I'm going to add that in to my HTML tag, and with that said, I'm also going to need to create the module itself, so I'll need a new file for that. I'm going to create a new file, call it App.js, and inside of here I'll create the Angular module and this is going to depend on two modules, the NG route module and the Firebase module. This is very important. If you're going to using AngularFire, you've got to remember to depend on the Firebase module. And with that set up, I can back in to my index.html, and I want to add that file as a script file. I also want to be able to put in some custom styles for my app so I'm going to add another style sheet. This'll point to /styles.css. Let's go ahead and create that file. I'm just going to paste in a few styles that we'll need later on. Nothing too crazy here, just a little bit of body padding, point to what class I can use and a hover delete class that will matter later on. Now I want to create my home page. I'm going to create a new folder and call it home. Inside of here I'll create two files, home.js and the template file for this which will be home.html. For now, we'll just put in an h1 tag that says expenses. Our home.js is going to be one of the new Angular 1.5 components. We create that by grabbing the module and we call the component method. Of course, I'll name this home and I'm just going to set the template URL property which is going to be that home file which is under home and then home.html. Now, with the home components created, I've got to go back in to my app.js file and create a route for it. So I call app.config and grab the route provider, and call route provider .when. And whenever they go to home, then I just want to use a template here and it'll be a tag, which is the home tag. Which matches the name of that component. This is how you route to components using the new 1.5 components. I won't put in a controller here like you might in older versions of Angular. You just put in a template for that component and that's all you need. I also want to set the default route, so otherwise will go to home. And that's all you need to do to set the route. Of course, some people like to put the routes alongside the components. I'm just going to keep all my routes in a central place in the app.js file, but that's a simple preference. Wherever you put your routing information is up to you. I need to go back in to html, of course, and add that home component and make sure it gets loaded. And of course the route won't work if there's not an ng-view directive. Just for some styling, I'm going to give the body a class of container. This is a bootstrap class that gives it a little bit of left and right padding. I'll save that, and now we're ready to run the application. So back to the command line, and we'll start up our app. I'm just going to use my npm start script and with the server started up and running on port 8080, I'll go to a browser and I'll hit local host 8080, and we can see it automatically goes to default route and our home route is showing up with that h1 tag that says Expenses.

Dealing with Refs
With our application up and running, the next step is to connect to Firebase. We do that using a Ref. Refs are pointers to a specific location in our Firebase, or in other words, data at a specific location in our Firebase. That means that Refs are always associated with URL. So, we're going to create new file called fbUrl. This will be the file that handles our Firebase URL Now, of course we don't want to duplicate any code, so we don't want our Firebase URL to be duplicated around our project, we're going to create an Angular service that will house our Firebase URL. I'm going to use the constant function since this never needs to change, and I'll name this FirebaseURL. The URL itself will be http://je-expense-tracker.firebaseio.com. Now we've got the URL stored as a service that we can access anywhere we want. The URL by itself isn't good enough, we actually need a live Ref. Now, if you watched my Firebase course you'll know that creating a Ref in JavaScript is done by using the Firebase function, which is a global function provided by the Firebase JavaScript file. You call new Firebase and give it the URL. Of course, we don't want to do that in our Angular file because Angular deals with services, not with globals. So let's create a new service on our same module, and I'm going to be a little bit cute here. The service function in Angular, we'll actually call new if you pass it a function. I'm going to name this service rootref and I'm going to give it a function. But I'm also going to take advantage of Angular's dependency injection by giving it an array where the first parameter is the name of a service I want to inject, in this case I want to inject my URL. So I'm using the name FirebaseUrl, which is the name of the service I created up here and I'm going to inject that into the Firebase function. So again, this is being a little cute, because what will end up happening is Angular, behind the scenes, will call new Firebase, and then pass in the URL that's represented by the FirebaseUrl service, which is this URL right here that we created. It'd be no different than calling this code exactly like this and putting that into a service. But we're doing the same exact thing with less lines of code. So it's a little bit cute. It can be a little confusing to somebody who isn't familiar with all these pieces of Angular, like how the service function works and how arrays work in order to enable dependency injections into functions, but it is very succinct code. I'm going to save this and go in to my index.html file and add the fbUrl file that I just created as a script, save that, and we can now go out to the browser. Refresh the page, we can see we're not getting any errors. But what we'd like to see is some kind of confirmation that we're connected to Firebase. So let's go back into our code and to our home component. We're going to add a controller. This is just so we can see we're connected to Firebase. We'll create a basic controller and we're going to inject the rootRef, that service that we just created. We're going to use a little bit of the underlying Firebase API to just listen to an event. So we'll go rootRef.on and we'll listen to the value event. This is not part of AngularFire itself, but this allows us to check that we're connected. We pass in a callback function and inside that callback function I'm just going to log out the fact that we are connected. Let's save that, go back to our browser and refresh. Now we're getting the message down in our console that we are connected. We're going to go back in to the code and we'll remove what we've done just for the connection message and that's how we get our Firebase connection.

Summary
In this module, we learned how to get an application started with AngularFire. Although we haven't begun dealing with any data, or even authenticated our user yet, we saw how to install Firebase in AngularFire and we also saw how to deal easily with Firebase connections which are called Refs. This module just got our toes wet. In the further sections, we'll really dig into AngularFire and start getting things done.

Authentication
Introduction
In this module we're going to implement login for our users. This is quite easy with AngularFire as you'll see. We'll start off by implementing anonymous authentication, but since that's not an authentication method that suits most applications, we'll also implement OAuth authentication. After that, we'll learn how to get the authentication status of the current user, next we'll learn how to log out users, and finally we'll learn about protecting routes so that users can't see specific routes until they're logged in. There are four ways to authenticate with Firebase. First there's anonymous authentication, which is convenient, but also means that users can't be tracked from one session to the next. There's the typical username and password authentication. Then there's OAuth, which has quite a few flavors such as Facebook, Twitter, and others. Finally there's custom authentication, which is useful in scenarios where your application already handles authentication and you need Firebase to meet your specific needs. With each of these methods, the setup and implementation is fairly easy, which is another great feature of Firebase. If you're following along, you've got to configure the authentication methods you want to support in your Firebase. So let's go on to the management console and we'll go down to the Login and Auth tab and then from here we're going to start by enabling anonymous authentication, so let's click on the word anonymous, and all you have to do is check this check box. Next we'll go over to the Facebook tab and we're going to check this check box as well and then at that point you've actually got to go in and create a Facebook application and get an app ID and a secret key. I won't walk you through this process, but instead if you simply go to this URL, then you can follow the process. It's got a few steps, but it's relatively straightforward. Once you've done that, just copy your app ID and your app secret into these two boxes down here. Now that we have that configured, we're ready to actually start authenticating our users.

Anonymous Authentication
The first kind of authentication we're going to add is anonymous authentication, but in order to authenticate at all, I want to do this through a login page. So let's create a new folder, I'll call it security, and inside of there I'll create a login component and its associated template and let's go into our app.js file first and let's create a route to login and it'll just be /login and we use a component named login and let's start with our login template and let's create an h1 that just says please login and we'll create a button, we use a class of button and button primary, which tells bootstrap to make the button look a certain way and we'll call this anonymous and just to be complete, we're going to give ourselves a place to display error messages and so I'll create a div with a class of alert and alert-danger and I'll display the error message inside of here and of course I don't want to show this if there is an error message so I'll add an ng-show and I'll set that equal to the error message itself, but I'll put on not at the beginning to make sure that it treats it like a Boolean and to show that I'm considering it a Boolean. So if there is an error message, it will display, if the error message is null, this won't display. But I don't want to put error message right on the root. I'm using a component and the components use the controller as syntax by default so the component is going to be named $ctrl by default. Unless you specify otherwise, this is the name of your component inside of your template. In previous versions when people used controller as, oftentimes they would use something else. It was very common to use VM as the name of your controller, but in Angular 1.5, the default name is $ctrl and with that we can go into our login.js file and create our component. So let's grab the app module, call component, name it login, and we'll point at the template and we'll give it a controller and right now our controller doesn't do anything. We need it to handle when the button is clicked to login anonymously. So let's create an anonymous login function. I'll call it anonLogin and from here I need to ask Firebase to login anonymously, but in order to do that I'm going to need a handle to Firebase's authentication object and I don't have one, I haven't created one. So before we create that, let's go back into the login.html and hook up this button click, right here, ng-click=$ctrl.anonLogin and I'll save that and now I need to create that authorization object for Firebase. So go to my security folder, create a new file, and I'm just going to name this auth.js. This is going to be a service and I use the factory function, which simply returns out whatever I return. The service will be named auth and I need to take in two dependencies here. The first one is the Firebase auth service, which is $firebaseAuth. This service is a part of AngularFire and it exists inside of this Firebase module that we're depending on and since we're depending on it, we can just inject it into our services and controllers. The second dependency that I need is my rootRef that we created earlier, which is the ref to the root of my Firebase and with those two dependencies, I'm going to return a call to the firebaseAuth function and I'm going to pass into it my rootRef and what this does is creates an authentication object based on this ref. Now I can actually give it any ref and it will still create the same authentication object because it's simply based on my Firebase. So I'm telling it which Firebase to use and to create an authentication object for that. So it's more natural to pass in the rootRef, but I truly could pass in a ref to any point in my Firebase. It really just matters that it's a ref to the right Firebase and now that I've created that service, I can go back into my login.js file and I can inject that auth service. Now this subject has several functions and one of them is the authAnonymously function, they're all prefixed with a dollar sign, and this function tells Firebase that I'm authenticating anonymously. This is also a promise so I can call then and I can do something when this happens successfully, I can also call catch and pass in a function that receives an error object and I can set that error message and I want to set it to the err.code function. Now I do have a binding problem. This anonymous function that I passed into the catch function, it's this object will by default not be the same thing as my controller and I want it to be the same thing as my controller. So in order to handle that, I'll add another parenthesis here and I'll call .bind, passing in this, and finally the wrapping parenthesis. We're going to see this quite a bit when we're working with components in Angular 1.5 in order to make sure that we bind anonymous functions to the controller itself. Now I'm handling the error message correctly, but what do I do when they do authenticate? In this case, I want to redirect them to the homepage and to do that I need to add another service as an injection, which is the location service this is a basic Angular service, and I can call location.path and pass in a URL and in this case I'll just pass in /home and now it will redirect to home. Now of course we always have to go into our index file and add in any new files that we created. We created two new ones, auth and login. And with that, we've got our login hooked up. We can go back to our browser, refresh the page, and we'll manually go to the login route where we have the please login message and the anonymous button, we click that and we're logged in and redirected to home.

OAuth Authentication
We've got anonymous authentication working, but for an application like an expense tracker, it's really not an effective authentication method. The reason being is every time a user comes back to our site they're going to have a different session and we won't be able to tie them to a previous session. So any data that they put in is going to get lost. We don't want that scenario of course, we want users to be able to come back in, login, and see the data that they've previously been dealing with. So with Firebase, you do have a lot of authentication options. We've seen anonymous authentication. It's also got your typical username and password authentication, which we would simply build the username and password box. We've got OAuth authentication and there's even a custom authentication if you have to do something really outside the box. The only real difference between the different authentication methods is the method that you call on the auth object. Here we're calling authAnonymously, but for a different kind of authentication we just call a different method. So let's implement OAuth login using Facebook. I'll start by creating a new method. I'm actually going to copy this method here because the new method we'll create is going to be very similar and instead of anonLogin, I'm going to call this fbLogin for Facebook and then instead of calling the authAnonymously function, I'm going to call authWithOAuthPopup. Now there is another method for OAuth where you don't use a popup, instead it's a redirect. We'll use the popup for our application, but you can do it with a redirect instead, it's just a different method name and it takes a one parameter, which is what kind of OAuth authentication we're going to do. In this case it's Facebook so we just pass in the word facebook all lowercase. Other than that, all this code is going to be the same. We're just going to redirect to the homepage if it's successful, otherwise we'll display an error message if it's not. I'll save that and go to my login.html page and I'm going to create a new button and we'll give it the same styles. And for readability sake, I'm going to put some of this information on separate lines. We'll add our ng-click event, calling ctrl.fbLogin and then the text will be login with Facebook. Let's do the same thing to this button so it's a bit more readable and then I need to fix here. I set style equals this, but it's actually class. And we'll save that file and we can go back out to our browser and refresh the page and let's go to the login page and now we get the options to either login with Facebook or login anonymously. If I click login with Facebook it'll bring up a little popup that just automatically logs in because I'm logged in on Facebook somewhere else in this browser. And of course, it redirects me to the homepage once it's done and now I'm logged in. One thing that's important to note here is that even though we have logged in both anonymously and with Facebook, we actually haven't affected the data in our Firebase at all. Let's open up our Firebase and look at the data. You can see here that our Firebase is completely empty. Even though we're logged in, there's no place here where it's tracking the login in our Firebase data. Firebase is tracking that for us somewhere else, but it's not in the location where we can access using the Firebase libraries. We can't read that data as if it were regular data in Firebase. We can simply login and logout and deal with the authentication methods, but it doesn't affect the data in our Firebase, that's important to know. If you do want the data in your Firebase to know about the logged in user, you have to do that yourself and we will see how to do that in the next section.

Getting the Authentication Status
Now we've got login working, but we have a small user experience problem and that is if a user's already logged in and they just go to the login page, they can login again, it doesn't let them know that they're already logged in. I'd like to change this page so that if you're already logged in instead of the buttons, you get a message that says you're already logged in. Of course at that point, we'd also like to let people logout and we'll handle that a little bit later on. So let's just work on a message that will let the user know that they're logged in. So here in the login component, I've got the auth object and I can actually ask that auth object if the current user's logged in. But there's a problem with asking that question right here. If the user refreshes their page, then for at least a brief moment until the page gets in contact with Firebase and finds out if the user is still currently logged in, the application and this auth object will think that the user's logged out. So we'll get one of those flashes of uninitialized content where the page looks one way for a second and then it flashes and looks a different way. We don't want that and of course with Angular 1 there's a built-in mechanism to deal with preloading data for a page and that's in the routing configuration. When specifying a route, like our login route here, in addition to specifying the template, we can also specify a resolve object. This resolve object let's us tell Angular that there's some kind of data that we want first before it navigates to this root. For every key that we create, if that key is a promise, then Angular will wait until that promise resolves before it navigates to the root. AngularFire has taken advantage of this and actually given us some built-in promises that we can use in order to get authentication information for a page. So I'm going to create a new resolve property called currentAuth and this will be the current authentication information. I create a function that takes in a parameter which is the auth service that we created earlier and that auth service has a waitForAuth method so I'm going to return that and like with all the other methods on the auth service, it starts with a dollar sign and this waitForAuth method is a promise that will cause the current route to wait until the client has the authentication information from Firebase. In this case it'll let us know if the user's logged in or not. Now this by itself will simply cause the route to wait until the authentication information is in place, but we'd actually like to access that authentication information and the object that is returned by this waitForAuth promise will either be null if the user is not logged in or it will be an object if the user is logged in and I want to feed that data to my login component. Now if we were using a controller for this route with Angular 1.4 or previous, then this name currentAuth would actually be an injectable parameter in our controller. But we're not using a controller, we're just using a template. So we need to feed the data into the template and there's a way to do that that's been added in Angular 1.5 and we do that by creating an attribute on this node, and I'll name it current-auth, and inside of the value of that attribute I'm going to specify $resolve.currentAuth. This $resolve object is an object that has a property that corresponds to the results of each of the keys of the resolve object for the route. So if I come down here in the route and add another property, and again this is a function, and if it returns some kind of a promise, then whenever the value is that resolves in that promise will now be available on $resolve.prop2 and in this case $resolve will have two properties, prop2 and currentAuth. I only need currentAuth so I'm going to undo that and delete this second property and this currentAuth property up here is going to have the value that's resolved by the waitForAuth call down on line 12 and that will be fed into my component, which I can simply receive by adding a binding property. This binding property is sort of a replacement for the scope property that existed on directives. It's a way to tell the component that some data's coming in. But we don't use a scope property because components only have an isolated scope. So we don't get to specify whether they have shared or inherited or isolated scope, they always have isolated scope. We simply can specify what bindings they have. So in our case, the binding is this currentAuth attribute here and of course that's dash case and here in our property name we've got to use camelCase. So it's going to be currentAuth like this. Don't get confused, this value here corresponds to the name of the attribute here. It doesn't correspond to the name of this property. I can change this name to whatever I want and that simply needs to match the name of the property on the resolve object. Those two names have to match, but this name here and this name here have to match. Now for readability sake, I'm going to go back in and change whatever back to currentAuth. Just don't be confused by that. And just like how scope properties worked on directives in Angular 1.4, we give it the same specification, in this case we're going to use an equals sign to indicate that it's a two-way binding. Now that I've added that, my controller is going to have a property called currentAuth. So I can create a new property on my controller, which I will name loggedIn, and I'm going to set that to be equal to whether that currentAuth property has any value at all or is faulty. So again, if the user is not logged in, this .currentAuth will be a faulty value, but if the user is logged in, then it'll be an object, which will turn into a true when I run the double not against it. Therefore loggedIn will either be true or false. And now that I know whether user's logged in or not, I can go back into my template and specify a few things. First off, I don't want to display my please log in message if they are logged in. So I'll add an ng-hide=$ctrl.loggedIn. Remember, $ctrl is our default name for our controller. And now that I've got that, I can add another message that I will only show if the user is logged in that says you have already logged in. I'd also like to hide these buttons if the user's logged in. I'll add this to this button and this one and now let's save that and we'll go to the browser and refresh our page and we're still getting the buttons. So there's a problem, I've done something wrong. Let's go back and check our code again and the issue is actually up here. The word is not binding, it's bindings, it's plural. Which makes sense because you can have more than one binding to a component. So there's something to look out for. Make sure you make that plural and not singular. Let's save that and go back and refresh and now you can see that our login page gives us our you've already logged in message and that way a user can't login again after they've already logged in.

Creating the Nav
We've got the ability to login, now we also want the ability to logout, but I'm getting kind of annoyed having to go up into my URL and put in my routes. So we're going to take a quick minute and add a navigational component. Let's go back to the code and I'm going to create a new folder called nav and inside of that I'll create two files, nav.js and nav.html. Nav.js is going to be a very simple component, we'll name it nav of course, and the only thing we'll give it is a template. And in our HTML, we're going to have to put in quite a bit of stuff here and I'll start off with a div with a class of navbar and navbar-fixed-top and then inside of that we'll create a container div and within that a navbar header and that will have an anchor tag in it, which will just go to the root and we'll give that a class of navbar-brand and this will be the title of our application, which is expenses, and next another div with a class of navbar-collapse and collapse and this will have inside of it a UL with a class of nav and navbar-nav. This is just a whole bunch of bootstrap stuff. If you know bootstrap, you'll recognize it, if you don't know it, it's an easy way to create a menu, but it's not really very important to this course so I'm going through this pretty fast. And I'm going to have a few list items inside of this. One is going to be our home and then we'll duplicate this and add a logout link and we'll have that point at /logout, which doesn't exist right now, we'll create it next. And that's good enough for now. So I'm going to save this and I'm just going to go into the homepage and I'm going to add this at the top. And then as always, we have to add this file to our list of files. And we can go back in the browser and refresh and we now get our navigational component up at the top. So I can go between home and logout. Logout of course doesn't exist so it doesn't go anywhere for now, but we'll take care of that in the next section.

Logging Out
We've got the ability to login, let's implement the ability to logout now. We've already got our nav pointing to /logout so let's go and create a route for that path. I'll copy and paste login and change it to logout. But we don't need most of this. We don't need a resolve property and we don't need to pass in any data and we could change this to just logout and now we can go and create our logout component. So I'll create logout.js. I'm not going to create a template for this file because our logout is just a piece of functionality with no view. But I do need to remember to go into index and add the logout file and our logout is going to be a component and it has no template, but it does have a controller and I need two services injected into it, my auth service and the location service. The auth service has the method I need to call to logout, which is auth.$unauth and that is the method that will log the current user out. And then once that's done, I'm going to redirect to the login page. And that's all I need to do to get my logout functionality working. So back to the browser we go, refresh the page, and I'll click my little logout link and I'm back to the login page with the opportunity to login. If I login with Facebook, I'm correctly logged in and redirected back to home and there you see how easy it is to do logout with AngularFire. We just have to call this unauth method and that's all there is to it. Now I implemented this as its own component. Of course how you implement your logout really depends on your application and the user experience you want. It might be a button on a page, it might be a drop-down menu, however it's implemented, this is the method that you call in order to get your user logged out of your Firebase.

Protecting Routes
The last thing I want to do with authentication in AngularFire is have the ability to protect a route. So ultimately our homepage is actually going to display the expense data for the user, therefore it doesn't make any sense for the user to be able to go to the homepage if they're not logged in. So obviously what I want is for the homepage to be protected behind login. Now I could go into the home component and I could ask for the auth object, check the current user's authentication status and if they're not logged in, I could navigate away, but there's a lot of problems with that. It might be trying to gather their data that wouldn't make any sense if the user's not logged in. So that can be a real problem. It makes it a lot simpler to make checks like this before you even go to your route using the resolve functionality in Angular 1. So let's go to our home route and let's add a resolve object and just like down below I'm going to call this currentAuth and I'll make almost the same function as we did for login, bringing in auth, and I'm going to return a call to a different method on the auth object. WaitForAuth simply says wait until we know the authentication status for the user before we go to the route. Instead of calling that method, I'm going to call $requireAuth. This method is slightly different from waitForAuth. This will also wait until the authentication status is known but if the authentication status is unauthenticated, so if the user has not logged in, and if the promise rejects, then Angular will not navigate to the route. It will instead throw a route change error. In the case that the user is logged in, it will resolve with the same object that waitForAuth resolves. So if I need that object, I can inject it into my template like I did down here in login, but in our case I don't need the authentication information. I simply need to not navigate if the user's not logged in. So this is half of what I need to do. The other thing I need to do is capture the route change error event and do something about it. So I'm going to go up to the top of this and add a new little section, it's going to be an app.run, and I'm going to pass in two things to this, the rootScope and the location service. Now I'm going to listen to an event on the rootScope, calling the $on function and I'm going to listen for the route change error event, which starts with a dollar sign, and that receives four parameters, the event itself, the next route, the previous route, and the error. I'm simply going to check and see if the error, which is just a string, is a special string that I know is going to be AUTH_REQUIRED all in caps. If it is that string, then I know that AngularFire has fired this event because of that requireAuth method on the auth object, in which case I just want to redirect back to login. And with that set up if we go back to our browser and refresh the page, then log out, and let's try to go directly to the home route without logging in, we can see it just puts us right back to the login page. But if we login, then we're able to go to the homepage no problem and there you can see how easy it is to integrate authentication with routes so that we can protect our routes using this requireAuth function and not allow the user to go to pages that they're not allowed to be on if they haven't logged in.

Summary
In this module we learned how to setup authentication in our Angular application. We saw how to authenticate with both anonymous and OAuth authentication, how to get the user's authentication status so that we can take action based on whether they are logged in or not, how to unauthenticate the user, and finally how to protect routes so that unauthenticated users can't get to post-login views.

Using $firebaseObject
Introduction
In this module, we're going to learn all about the Firebase object service. You will usually think of this as a service but since you use it to create an object you may often think of it either as a constructor or an object. We'll build the first pieces of functionality in our application, giving our users the ability to save some preferences. As we do this, you will see how to use the Firebase object for most typical scenarios. So really, what is this service? In a nutshell, this is the functionality provided by AngularFire to allow you to retrieve data from your Firebase as an object. There are two types of data you'll want to retrieve. Either a list of data or just an object graph of data. Firebase actually stores them both the same, but AngularFire gives you the option to access and treat the data the way you want. Let's look at an example. If you have the given data here, you wouldn't want to treat it as a list. This is obviously just some data in a graph, not a list of data. So in this case, you'll want to use the Firebase object service. When you use the service, you'll have to tell it the URL to the piece of your Firebase that you want it to retrieve. In our case, we'd use the URL "/preferences." We would create a ref at this URL and then feed it to the Firebase object service. The Firebase object service would then return a JavaScript object that looked like this. Notice that the preferences key isn't in the return data. Just the data underneath it is returned. This is how we usually access our object data. But consider the following scenario. Let's say you give the Firebase object service the URL "/preferences/displayName". In that case, there's only a primitive value. In this case, you'd have to use the $value property in order to get the string "Roger". Generally, you won't access just a single piece of data. You'll usually access a bigger piece, but it's good to know that this functionality is available. In this module, we'll look at most of the commonly used methods and properties on the Firebase object, but there are a few we won't look at that are useful to know. First, there's destroy, which lets you stop listening to changes to data. This can be very useful. For more information about this, check out my course on Firebase. There's also the ID property, which tells you the key of the object you have a reference to. Generally, this isn't very useful because you already know it, but it can come in handy in certain scenarios. In the first example given above, when you point at /preferences, the ID would be the string "preferences". And then there's remove for deleting data and finally the ref method, which gives you the ref that was used to create this object. Again, generally this isn't useful since you'll usually already have a handle to it, but there are some scenarios where this can come in handy. Let's take a quick look at our agenda. First, we'll talk about getting child refs from a parent ref. This is going to be important to us when retrieving just the data we want. Then, we'll use resolve to query data. This is a standard method in Angular that could be used to retrieve data before a route is hit. In our case, we'll see how to use it to retrieve Firebase data. After that, we'll look at how to display and update data, and then finally, we'll look at a very cool feature of Firebase called "three way binding". If you're familiar with two way binding in Angular, this is the next step up. It allows you to keep your Firebase and all of your data in Angular completely in sync all the time.

Getting Child Refs
The next feature I want to add to our application is the ability for a user to store and retrieve some preferences. We'll create two preferences. One will be a display name and the other one will be a selection between a dark theme and a light theme. So, since we're adding this data to our Firebase, we've got to do data design. We have to decide where we want to store this data. Of course, we could just create a root user's node and stick everything under there, but that is not good design. If we go to our Firebase data and we imagine that underneath this node, we've got a user's node, and underneath that is a list of every user, and then within each user, we have all their preferences and all their other data, that seems like a very logical design at first, but over time, this will actually become problematic because too much data's grouped together. Later on, we might want to select a list of all of our users, but in Firebase, when you select any given node, you have to get all the data underneath that node. So if we selected all the users, we'd be essentially getting every piece of data in our Firebase. All the expenses for every user, all their preferences. We don't want that. Instead, what we want is a top level preferences node that is going to contain underneath it one node per each user, and then under the node for the user, we'll have their display name and their selection for a theme. This matches the needs of our application much better. So the first thing we will need is to be able to get access to that data which is not at the root anymore. We have our root ref here in our fb URL service, but we're going to need to access the preferences for a specific user. To facilitate that, I'm going to create a new file and I'm going to call this "fbRef". This'll be a service that has methods that will give me easy access to any ref that I might use in my application. So I'll get my module, I'm going to call factory, I'll name it "fbRef," and I want two services injected, one of which is that root ref. That's the ref that points to the root of my Firebase, and the other one is the auth data. And I'll return an object that's going to have a set of methods. Right now, I really only need one method which is get the preferences ref, and this is going to return the root ref, and we're going to get the child, which is the preferences node, and underneath that, we want the child for the currently logged in user. So I'm going to use auth and I'm going to call the $getAuth function. This gets the authentication information for the current user, and it has one specific property that I care about, which is the UID. This UID is always valid as the key for any node. So this way, I will get a ref for the current user underneath the preferences node. Now with Firebase, if I wanted to, rather than using the root ref, I could create a new Firebase ref using the Firebase function passing in the URL, and of course, the URL is something like "https://" and et cetera, and then from there, adjust append on preferences and also append on the UID for the current user calling the same method here, but it's much easier to do it the way that I've already done it, calling the child method. Again, with Firebase, it really doesn't matter if we create a lot of refs using the Firebase function. It's not an expensive operation, and it doesn't open up new connections to Firebase, but it's just more convenient to take advantage of Angular's dependency injection, have a single root ref, and then just navigate within them. Now that we've created the file, of course we need to remember to add it to our index study HTML, so we'll add a new line and point at that new file. So this is good enough to give us the right ref, and in the next section, we'll create our preferences page.

Building the User Preferences Page
To build my user preferences page, I'm going to need quite a few pieces. First, I want to add it to my navigation. So I'll go in here and add a new navigational link, which I'll call "preferences", and the URL will be "/userpref". Next, I'll create the component in the template. So we'll put that in a new folder, which I'll call "userPreferences," and the component will be "editUserPref.js," and a matching template. While I'm thinking about it, I'll go down to my index page and add that file. I also need a route for it, so let's go into app.js and add a route. Since I want to protect this behind login, I'm going to copy the home route and duplicate that. The name of the component I'll make "edit-user-pref," and we've got this behind authentication using the requireAuth function. That's exactly what I want, so I'll save that, and we'll go into our HTML page, and let's add the HTML. We'll start with nav and then an H1 tag, and next we'll create a form with a class of form inline. We don't need an action on this form, so I'll take that off. I'll make a label for the display name, and I'll create an input for it. Type will be text, the ID will be display name, and we'll put in a place holder. I also want to give it a class of form control, and that's bootstrap class that'll make this look nice. And finally, I want to read the data. So I'll add an ng-model, and since this is a component, I'll bind this to $ctrl, and we'll put it on a userPreferences object, and we'll bind to the displayName. I'll put in a couple line breaks and another label for the theme, and then this will be a selection box. The name will be "themeColor". The ID will also be "themeColor". I need to add in a couple more things. I'll put in an ng-model, which is ctrl.userPreferences.theme, and then we'll use the ng options to create the options for this, and I'll do theme for theme in ctrl.themes. So that means I'll have to create a themes property in my controller that has all the options in it. And the last thing I want to do is set a class of form control. That's all I need for my select. A couple more line breaks, and we'll put in a couple of buttons. We'll make these small buttons, and this will be "Save", and we'll do another one that'll be "Cancel". They also need click events, and we'll just make the save method call here and the same thing here except we'll call cancel. And that's all we need for the HTML. We can go into our JavaScript file now and create our component. Again, this is editUserPref, and it has the template, and it has a controller. I want to inject that new service that I created in the previous section, the fbRef service, and I'll first want to create the themes. So this.themes will be set to an array that has two elements, just a string "light", and the other one will be the string "dark". And those'll be the values that go into my Firebase under the theme property for the current user. And then next, we'd need to select the user preference data from our Firebase, and I'm going to be selecting it from fbRef.getPreferencesRef which will get me the preferences node for the current user, and here's where we're going to get introduced to the Firebase object that we talked about previously. We're going to inject that Firebase object, so I'll go back up here and inject it. And then I'm going to take this ref, and I'm going to pass it into the Firebase object calling it as a function. So there, I've called the Firebase object as a function passing in the ref that points at the data I want to bind to. And now, I can set this.userPreferences equal to that Firebase object, and it's going to bind the data at that location onto the userPreferences property of the controller. So we've got the data bound and now, we need to deal with clicking the save or cancel button. So let's create those methods. The save method is the key. We want to actually save the data back to our Firebase. So in that case, we're going to call "this.userPreferences.$save()". This is a special method that's put onto the Firebase object that we created on line nine that will allow us to save the data to the Firebase, and then we also need to implement a cancel method, and in this case, I think we'll just navigate back to the homepage. So let's bring in the location service, and we'll call "location.path" and go to home, and now we got that method implemented and the save method implemented, let's go and run our page. Back to the browser, we'll refresh the page, and now we have our preferences link. We'll go there, and you can see that our display name is blank and our theme hasn't been selected. I'm going to put "Joe" in the display name, and for theme, I'll select light. Now, I click save and we have a little bit of a user experience issue because nothing happens. We don't get any notification that we saved, but let's go and look at our data. All of a sudden, we've got this preferences node that didn't exist before. If we open that up, we can see there's the key for our current user. That's their user ID. Here's the display name, and here's the theme that we selected. So that's fantastic. We're automatically saving the data. Let's fix the user experience issue by going back and once they do save, let's also route back to home just to let them know that they saved successfully. It would be nice to add a little message or something, but that's a little bit beyond the scope of this course, so we'll just redirect to let the user know that we saved successfully. Back in here, we'll refresh our page and now, we're getting our data filled in. And if we change the data and save it, we go back to home page, go to the preferences page, and we've got the correct data.

Injecting Data with Resolve
In the last section, we made our user preferences page work, but we've got a small issue. If we go in and refresh the page, you'll notice there's a moment when the display name is empty and the theme color is unselected. We'd like to avoid this issue and actually preload the data before we go to this page so that it's automatically selected. We already know how to do that because we did that with the user authentication data. We use the resolve object in our route. So let's go back to our code and go into our route for our user preference page, and we're going to add another property to our resolve object, and I'm going to call this "userPreferences". And here, I'm going to do the data selection that we did in our user preferences page right here. So I'll need the same fbRef service and the Firebase object service. And I'm going to take the code from here. So I'll grab this call here, cut it out, and return it, except I can't just return the Firebase object because it's not a promise. It's just the data. What I actually want to do is return this object after it's been completely loaded. Thankfully, the Firebase object gives us a special method for that, and that is the $loaded method. So if I return that loaded method, it's actually a promise that will get resolved when the data has been loaded from Firebase, and it will get resolved with the Firebase object. Now of course, to make that work, I've got to add it to my template as a binding. So I'll create an attribute called "user-preferences" and I'll set that equal to $resolve, which we've already seen before. And this time, the name of the property is "userPreferences". Save that and go to my editUserPref and add a bindings property, and I'll name this userPreferences and set it as a two way binding. Now, I no longer need this line of code here, and if we save and go back to the browser and refresh, you'll notice that we're no longer getting that flash of uninitialized content. The minute that this page loads, it's already got the data, and it's already filled in correctly. Now, we got everything working correctly so far, but we do have one bug that will only show up if we log out and then try to go to the userPref URL. You can see down here we're getting an error. If we scroll up and look at the error, it says "cannot read property UID of null". This is in our fbRef line four, and if we go to our code and look at that file, line four, the UID is for the current user, but if we're not logged in, there's no current user. You would think it wouldn't be trying to call this getPreferencesRef, but look at our app.js file. Here in the route information, we're trying to grab two pieces of information, the current auth and the user preferences. Of course, current auth will not resolve if the user hasn't been logged in, but there's no way to specify an order of these two resolve properties. So the user preferences is still going to try to execute, and it's still going to try to call this getPreferencesRef method even though the user hasn't been logged in, and we don't want that to call. Thankfully, we can solve this very easily because of the way that promises work. I'm going to add the auth service here and then, I'm going to wrap this in a return auth.requireAuth, and I'll call then, which will only get executed after the requireAuth promise is resolved, and I'll pass it a function and wrap this return statement inside of that. That will chain these two promises together so first, we'll check requireAuth and if that's okay, then we will create the Firebase object and return the promise that only resolves when it's loaded. At that point, we can actually get rid of our current auth property right here because we're not passing that data into our template and all the functionality is implemented in the user preferences resolve property. So it both checks that the user's logged in and it also gathers the data. So let's save. We'll go back to our browser and refresh the page, and now we get redirected to login without an error, and once we log in, we can go to our preferences and the data's been loaded correctly. So it's very easy to chain these different promises together so that you can gather data that you only have access to once the user's been logged in just by wrapping it inside of the requireAuth call.

Utilizing Saved Data
Now that we've got the user preference data saved in our Firebase, let's utilize it. I'm going to go into my nav HTML file, and I'm going to add another section. After this first UL, I'll add another UL with a class of nav, navbar-right, and navbar-nav, and it'll have one item in it with class of navbar-text, and we'll say "welcome" and then the display name of the currently logged in user. So we'll bind to ctrl.userPreferences.displayName. In addition to that, I also want to change the navbar from its normal display, which is going to be a white background, to having the navbar inverse class if the user has selected the dark theme. So I can't just add it here. I've actually got to add an ng-class attribute, and we give it an object, the key of which is navbar-inverse. That's the class I want to have, and I only want to have it under a certain condition. So we could do this a couple of ways. We could actually compare the user's current theme to the word "dark" or we could use a derived property. So let's just use a derived property. We'll create a property called "darkTheme" and we'll set that to true if they have chosen dark as their theme, and we'll set it to false if they've chosen light as their theme. So let's go into the nav.js file and I'm going to add a controller to it, and I need two services, the Firebase object service and the fbRef, which I can pass into the Firebase object. So I'll create a preferences variable calling the Firebase object function passing in fbRef.getPreferencesRef, and now I need to be able to set the dark theme property to true if the user has chosen a dark theme and false if they haven't. So let's save this and go back to the browser. We'll refresh the page, and we'll switch from light to dark, and save, and unfortunately, our navbar hasn't changed from a light background to a dark background. Let's check and make sure the data got saved. Yeah, the data got saved. We got the dark theme, but it's still using a light background for the nav. If we refresh the page, it's still light. So something's wrong. Well the issue is the fact that we are setting this dark theme variable immediately. Unfortunately, retrieving the data is a synchronous operation. So this preferences variable doesn't get filled in immediately. It only gets filled in after a certain amount of time. So when line five executes, the preferences variable has not been filled in with data. Now, we can work around that by utilizing that same loaded function that we saw previously. If I call preferences.$loaded, this is a function that's on every Firebase object, and it returns a promise that resolves once the data's been loaded. So I can call .then, passing in a function that receives the actual Firebase object as a parameter, and I'll just name that "data". And at that point, I can call this line of code, but of course, this inside of this anonymous function won't be the same thing as my controller, so I've got to bind this function to this, and now if we save and go back and refresh our page, you can see that the theme has turned to a dark theme, but notice we've still got a problem. If we refresh our page, we get a flash where the theme is light and then it goes dark. Now, we can fix that by putting our entire nav inside of an ng-if and only display the nav once the data has been loaded. So let's go back to our code, we'll go into our HTML file, and this outer div, I'm going to give it an ng-if directive, and I'm going to look for a property on my controller called "loaded". That way, this will only display once this loaded property has been set to true. Now, I'll go back to my nav.js, and I'll start off by setting this.loaded equal to false, and then inside of the loaded callback, I'll set this.loaded equal to true. Now, if we go back to our browser and refresh, we no longer get the flash of white and then black. Instead, the nav delays its rendering until the data has been returned, which does cause a different kind of flash, but it doesn't cause us to see content in one form and then in another. Now, even though we've got the theme working correctly, our welcome message still doesn't show the user's display name. Let's go back to the code and we'll remember that our display name is bound to the user preferences property of the controller. So let's go back and instead of saying "var preferences" we'll say "this.userPreferences" and grab that and paste it in here and here. And if we refresh the page, we now got our display name showing. So everything's correct except we are utilizing a bit of an anti-pattern. Doing much work inside of the loaded method is generally not recommended. There's a few reasons for this, but the primary one is that your code gets a lot more difficult to comprehend as you have initialization code that is temporally out of place. Here, the code in the loaded callback runs after other code because it's asynchronous. In this situation, because we have so little code it's simple, but as it grows it can quickly get out of hand and get very ugly. We can solve most of these problems with route resolvers to preload data before our controller ever runs, but there might be circumstances where we still need to listen to the loaded event. In that case, the ideal is to try and put as little code in there as possible. So there's another way to skin this cat. Instead of setting the dark theme property inside of the loaded method, we can actually put a watch on our user preferences. So this is Angular taking care of watching to see when it's set, and to do that, we call "this.userPreferences.$watch". Remember, userPreferences is a Firebase object which is from AngularFire and it has this $watch method, which under the covers actually calls Angular's scope.watch method. And here we call a function, and we can call this method right here. Again, we're using an anonymous function, so we need to bind it and close this up, and save, and then go back to the browser, and refresh. We've still got the correct behavior. Now, the other way we can do this is to actually preload the data through the resolve method, but there's a problem with that in that our particular case, the nav is used on most of the pages, but the nav itself isn't a direct route. It's the homepage and the edit user preferences page that are the routes. So we have to inject the user preferences data into those pages and then from there, re-inject it into the nav, which that could be a little bit cumbersome, passing data around like that. So in this case, getting the data directly inside of this controller is maybe not an optimal solution, but it's a trade off to do it this way versus having to have every page that utilizes the navigation grab the user preferences data and just pass it on. Now, in our case, we can actually simplify this because we don't need to use this dark theme generated property. So I'm going to cut out my watch, and I'm going to go into the HTML for the nav, and instead of binding it to dark theme, I'll say "controller.userPreferences.theme" is equal to the string "dark", and that gives us the same effect but simplifies the code in the controller. And we can see if we go back to the browser and refresh that we still get the right behavior. We don't get a flash of white and then dark, and the display name is bound correctly.

Three Way Binding
With Angular, one of the things that you can do is to a binding where you have an input box and a binding to that same data, and as you change the value in the input box, the data changes instantaneously. Well with Firebase, you can utilize that same thing to keep your database in sync as you change the data, and this is called three way binding. So let's see where we might use this. In our preferences page, if we go in and change the display name, notice that as we change it, it's changed here, but it hasn't updated up here in the corner where our welcome message is. Same thing for the theme if I change from dark to light. Nothing changes until I click the save button. And at this point, Firebase is updated, and therefore, our welcome message and our theme are changed. But with three way binding, we can make these changes instantaneously. In order to do that, we're going to go into our userPref controller, and I want to set up a three way binding on the user preferences data. So I'm going to change my binding. Instead of using the name "userPreferences", I'm going to call this "userPrefData" and then here, I'm going to specify that the attribute is named "userPreferences" but it internally in the controller, it'll be called "userPrefData". Now, I can call this.userPrefData, and remember, this is a Firebase object. This data comes from our route information and it is the Firebase object that we create right here that's being sent in. These Firebase objects have a method called "$bindTo". Of course, starting with a dollar sign, and in the $bindTo method, it takes in two parameters. The first is the scope, and the second is the name of the property that we want to bind to. Now, we don't have the scope object because we're using the controller S syntax on our component, but we can bring in the scope object. So let's go up to our function and let's bring it in. We don't need the Firebase object anymore because we're not creating a Firebase object here. So I'll change this to $scope, and now, my first parameter can be $scope, and my second parameter is going to be the name of the property. While in Angular 1.5, components by default are called $ctrl, but this is actually just a property with this name created on the scope. So I can use that information to bind to $ctrl.userPreferences and that will ultimately set up a binding on $scope.$ctrl.userPreferences. This is how Angular's controller S syntax works. The controller's name, $ctrl, is just a property on scope. So this is just like a regular watch binding where we pass in scope and pass in the name of the property, but in this case, it's a sub-property on the $ctrl property. Now, this bindTo is a promise, so we call ".then" and we pass in a function, and we can check to see if the theme has been set, and if it hasn't been set, we'll default it to the first value. That way, for new users, they're still going to get a default value for their theme, and since we're using anonymous function, we still want to have the correct this context. We'll bind it to this and wrap that up here and save our file, and now if we go up to the browser and refresh, we can change the theme from light to dark, and it instantly changes our theme. We can change our display name, and it instantly changes the display name. What's more, if we go and look at our data, we can see that the data has been kept in sync. Even though we never clicked save, our theme is set to dark and the display name is set to "Joey". So this is how you implement three way binding in AngularFire. You get a Firebase object, which is in our case userPrefData and you call its $bindTo function. Then, you specify the scope and the name of the property that you want to bind it to. At that point, you have set up three way binding. The only reason I called this then function was to set up a default value for the theme for brand new users when they log in. If I didn't need to do that, I wouldn't even have to call this then function. I could just simply call the bindTo function all by itself and everything would be set up correctly. Remember, we can't use the same name user preferences as the data that's coming in because they will conflict with each other. This bindTo is creating a brand new property on the scope. So if we name our binding "userPreferences", that property will already be set. We don't want it set because our bindTo function is going to create and set that property and keep it in sync. This is a very cool feature in AngularFire. It lets you keep the data in sync and basically make your application realtime with very little work on your part.

Summary
In this module, we learned all about the Firebase objects service. The key points we learned were how to retrieve and update object data, how to use resolve to pre-fetch our data, and how to use the very cool feature of three way binding. The Firebase object service is the facility provided by AngularFire to access non-list based data in your Firebase and it's something that you will definitely find useful in your AngularFire apps.

Using $firebaseArray
Introduction
Here in our final module we'll be talking about the $firebaseArray. This piece of AngularFire allows us to deal with arrays and lists of data. We've created very little of our app so far because we don't yet have the capability of displaying lists of data. That's what we're going to learn in this module and so we're going to be buIlding a lot more of the pieces of our app. Let's talk a little bit about arrays and how Firebase handles them. Remember, Firebase does not have arrays. What it has is objects. Objects have keys. So lists of data in Firebase are essentially just a list of keys. That's why we have the $firebaseArray. It translates between the objects on the Firebase side and arrays in Angular because in Angular we're going to want to be using arrays to display our lists of data. It would be a lot more difficult to have to use objects in order to display lists of data. Thankfully, AngularFire's handled this with the $firebaseArray. It is an important note to remember that in Firebase when dealing with arrays, you should not rely on indeces. Don't keep track that a certain element is the fifth element of an array. If somebody else modifies the array, the indeces will shift and you can be off. So as much as possible, try to use the keys of the objects or pointers to the actual objects themselves. Don't use indeces. Let's take a quick look at our agenda. First we'll talk about displaying lists of data, we'll talk about how to query that data and get it back in a certain order that we want, we'll talk about how to add records to a list, and then we'll look at extending the $firebaseArray, which is a really cool piece of functionality that lets us add our own functions to our array objects. Then we'll look at how to delete data, after that we'll learn how to edit data, and finally we'll learn about the new features in version 1.2 of AngularFire. Even though we'll be covering most of the important methods on the $firebaseArray object, there are a few methods that we aren't going to cover. Those are the $destroy method, which allows us to stop listening to a piece of data, if you've watched my course on Firebase you'll understand why this is so important, the $getRecord method, which allows us to pass in a key and get the matching record for that key, the #keyAt method, which allows you to pass in a record or an index and get the key for that record, the $ref method, which gets you back a pointer to the ref that was used to create that $firebaseArray, and finally the $watch method, which allows you to watch an entire $firebaseArray. These methods are useful and are useful to know about, but the other methods on the $firebaseArray we will be using in the source code that we write.

Displaying List Data
In this module we're going to be learning how to deal with lists of data in AngularFire. Now rather than start with the more complex list, we're going to start by displaying a very simple list, which is a list of categories. Every expense in the expense list must belong to one of several categories. So we'll start learning how to deal with lists of data by creating a page that will list the categories and let us maintain that list. So let's go to our code and we'll need a link to our page so let's start in the nav.html. I'm going to create a new anchor tag and it's going to point at our categories list, the URL will be categories, let's save that, and let's also go and create a route. So in our app.js file, this page will display the list of categories so let's follow best practices and actually gather that data beforehand and inject it in our resolve method, therefore this will be most close to our userpref route. So let's copy that, paste a new one in, and we'll name it categories and the name of our component will be category-list and the name of the data attribute, we'll make this categories, and let's also name the resolve property categories. So that'll be the name of our property. We will name the fbRef service to be injected in and the auth service because this needs to be behind login. So we'll want to keep this line 35 the same, but we won't need a Firebase object, instead we're going to need our $firebaseArray. With that injected in, we basically do the exact same thing, we call it as a method and pass in the ref that we want to point at. Now instead of preferencesRef, we're going to need an entirely different ref and we'll call this categoriesRef, which means we'll also need to go to our fbRef service and add a new method. So we'll save this here, go to fbRef, and we'll add a new method and that's named getCategoriesRef and it will be categories. Now unlike preferences, categories are not organized by user. It's a common list for all users. So our data design will simply be underneath the root node we'll have a categories node and underneath that will be a node for each category. Very simple, therefore we don't need this child for the current user ID, we'll just end at categories. Again, it's always important whenever you're adding new data to your Firebase to consider the design of the data. How can you best design the data to work correctly with your app so that selecting it, writing to it is the most efficient operation possible. In this case, it's very obvious. We have a list of categories, we'll just create a new node underneath the root node for categories, but in other cases it could be more complex so always thinking about the design of your data is important. Next we'll want to create our categories component. So let's create a new directory here and we'll call it categories and inside of this we'll create two new files. The first one will be categoryList.js and the other one will be categoryList.html and let's close this working file so we got a little bit more space. Before we forget, let's go down into our index.html and let's add that new file to our list of scripts and let's start inside of our HTML page, inside of this template we'll put in a nav and then an h1, which displays the name of our page, which is categories, then let's put in a div, but this div is going to show for each category. So let's put in our ng-repeat and we'll just do category in $ctrl.categories and let's just display the category name and that's enough for a very simple display. Let's go into our category list file and this is a component, which we named categoryList. It's going to have a template. It's also going to have bindings. In this case we've just got the one binding, which is the categories. And it will need a controller, but I'm just going to leave that controller empty for now because we don't have anything for the controller to do. In the next section, we'll consider the design of our data and also how it's going to be ordered.

Querying List Data
Our page right now is basically working, but we don't have any data to display and we haven't really given any thought to the order that the data will display in. The categories are just strings. The name of each category is what's important. So we're going to bring down that list. We're going to display the name, which is a string, and we'll probably going to want to have it in alphabetical order so we need to sort the list of categories. Now we can do it client side using a filter in Angular, but that's a much less effective operation than doing it server side, especially if we have an index. So let's actually go back to where we select the data, which is in our app.js in the route and right here, the getCategoriesRef. We're going to create a query so that we're getting the data in the order of the name field. In order to understand how to create this query, we really need to understand how the data looks and we haven't really seen our data. So let's take a quick jaunt over to the browser and let's go into our Firebase data list and let's actually create some data so that we can understand what we're doing and I'll collapse this preferences and I'll create a new node called categories and since this is a root node, it doesn't have a value, I'll create another node underneath it and this is where my list of categories will be and each one will need a key. Remember, lists in Firebase are not like arrays, they don't have a numeric index, they have a key just like any object property. So lists in Firebase are far more similar to objects in JavaScript than they are arrays. So let's create a key, I'm just going to put in a random key. That's one of the great things about Firebase is even though it'll create keys for you automatically when you add new data to a list of data and the key that it creates is going to have an embedded time stamp into it as to when the data was created so that it will sort correctly by created data, it really doesn't matter what the key is so long as they are unique. So the key that I'm going to create is just five As and then instead of creating the value as the category, I'm going to create another node underneath here and the name of this node will be name for the name of the category and the value will be the first category and this one will be books and now I can go ahead and add the data and that's how my data looks. Let's create one more category and the key will be 5 Bs and the name of that category will be Computer Equipment. So I've now got two categories, Books and Computer Equipment. Again, the data design that I have chosen where I've got a key and underneath that key is a list of attributes of which I've only got one right now, name. Maybe later on I'll have more attributes. So this design actually supports adding more attributes to it later on. There is other ways to design this data, this isn't the only possible way to design this data, but this design works well for our needs so we're going to leave this as is and now that we know what the data looks like we can go back into our code and we're going to create a query that orders the data by the name property. So I'm going to create a new var here called query and I'm going to set that equal to fbRef.getCategoriesRef.orderByChild because I'm going to order each key by its child, which is the name property. Going back to our data, what I'm selecting is these nodes, the A, the B node, and I'm ordering each of them by their child, which is the name property. So the orderByChild function takes in one parameter, which is the name of the property we're going to order by and the name of it is just the string name and now in our $firebaseArray I just pass in that query and that will select the data, order it by the name property and then create an AngularFire array out of it and that will finish up our data selections. We can save that page and go back to our category list and save this and before we save and go on let's just double check that what we've done is correct and I can see I've got a typo up here. That should have been HTML and I wrote in HML. Let's correct that and we'll go back to the browser, go to our app, refresh the page, and we've now got our categories link, we'll click on that and it's displaying our list of categories for us. So there we have it, a basic display for data using the $firebaseArray.

Creating List Data
Now that we're displaying our list of categories, let's give ourselves the ability to add new categories to our list. Back to the code, we're going to go into the categoryList.html page and start in there. We want an input box and let's give it this ng-model directive, which we'll set equal to the $ctrl.newCategoryName property and then we'll create a button with a class of BTN and btn-primary and btn-small and this will be the text create and let's give it an ng-click, which will be our controller and we'll create a method called createNewCategory and now let's go back to our code and inside of our controller we will create that method. Now the question is how do we add a new category to our categories list? Our controller has a binding to categories so this .categories will be that $firebaseArray object that is created and wraps around our data and it has an add method, which of course starts with a dollar sign, and we can just pass in a JavaScript object and it will save that object to the list. Now we don't need to worry about the key of the item, that will be generated for us, we just need to worry about the data. So again back in our data, the only property the object has is a name property. So we will create an object with a name property and we'll set it to this.newCategoryName, which matches the ng-model directive that we put into our categoryList.html page. And finally after we add the category, we're going to want to blank out that index box. So we'll set this.newCategoryName equal to an empty string. Let's save that and test out our changes. Refresh the page and let's create a new category, we'll call this Office Equipment and click the Create button and you can see that it's added that category to the list. If we go to our data, we can see we've got a new node underneath categories and this has the generated key. Notice this generated key is a big, long string, it often starts with a dash, and underneath that we've got our name property with the value. So it looks just like the ones we created by hand, but it has a generated key instead of the key we created by hand. While we're at it, let's add one more category, Travel Expenses, and that should do it, that's a decent list of business expense categories and we also learned how to add new items to a $firebaseArray, which was very simple, we just called the $add method on the array itself and passed in the data we want to add.

Displaying Complex List Data
We've got our app displaying our categories data, now let's display something a little more interesting and meaty. Let's display our expenses data on the homepage. Before we work on the code though, let's talk about the data. I've actually gone in and preloaded some expenses data. We've got this expenses node that's completely separate from my preferences node and my categories node. Just like preferences, when I open up expenses, I've got a node for each user, this is the node for my user, and within that user node, I'm going to have a list of the expenses. This first expense is opened up, here's its key, and we can see the properties that we're going to be storing, the amount of the expense, the category, which we'll look at in a second, the data, the description, and finally the payee. The category's interesting because I didn't just put the category name in, I actually created a sub node for category with the ID and the name. Remember, in Firebase there are no foreign keys so even though we have a categories list elsewhere we've got to duplicate that data if we want access to it from within our expenses. Again, I could have just put the name in, but oftentimes when you have a duplicated piece of data, it's nice to have the ID in case you need to look up the original data for some additional information. It's much easier to grab a node by its key, in this case the key for computer equipment is these five Bs, and grabbing it by key is a much more efficient operation than looking it up any other way. So now that we know what our data looks like, let's go in and create a basic display for this data. Back to our code, we're going to start in our home.html page and we're going to add in a table. This table is going to have a class of table, which is a bootstrap class, and table-hover and table-condensed. That'll make the table a little bit smaller. It'll also give us a hover effect for each row. And let's create a thead and within that a hole bunch of THs. We'll give them a width and that'll be 18% and this will be our date field and I'm going to copy this a bunch of times. This will be payee, description, category, amount, and this is a future field, I'm going to make this one a little bit smaller. This will have our delete link, which we'll implement later on. Finally, a tbody with a class of pointable, that's a class I created and put into my custom CSS file, and TR here with an ng-repeat, this TR will be duplicated for each item in the $firebaseArray, and we'll just do expense in $ctrl.expenses and this is going to have a bunch of TDs. Each one of these is displaying a separate field. We'll start off with our date, which is going to be expense.date and let's format that as a short date. Then let's do payee, that doesn't need to be formatted 'cause it's a string, description, and then the category name, this is again a subfield, then an amount, which we will format as currency, and finally one more TD with just a blank space in it. We'll fill that one in later on. So that's our display. Now we need to get the data in and we want to gather the data of course in the resolve method. So I'm going to copy what I've done here for categories and go up to home and I probably should have copied a little bit more of this. Let's copy from that area and we'll replace our current auth and we'll name this expensesInOrder because we're going to order them and instead of categoriesRef we want an expensesRef, which doesn't exist yet, we'll have to create that, and we're going to order by child, but let's order it by the data and we'll also need to inject that data. So I'll create a new attribute called expensesInOrder and set it equal to $resolve.expensesInOrder, which is this name here, and now let's go create that method in the ref. So I'll copy and paste this method, but it'll be named expensesRef and it's going to be much more similar to this one, but instead of preferences it's expenses and now we can go back to our home component and add in a binding and we named it expensesInOrder and since we named it expensesInOrder in our binding, let's go back into home.html and fix this so that it's expensesInOrder and now we can go back to the browser and refresh the page and go to our homepage and we can see our data showing up and being rendered.

Creating a Display Component
Now that we've got the expense list displaying, let's do a little bit of refactoring and put the display into its own component. I'll start by creating a new folder called expenses and inside of this folder I'm going to create two files, an expenseListDisplay component and an expenseListDisplay template. Let's start in the template. I'm going to go into my home.html file and I'll grab this entire table and cut it out of here and then we'll paste it over in the expense list display and now let's go create our component and I'll name this expenseListDisplay and it's going to need to bring in the expenses it displays. So I'll create a binding, which will be named expenses and we'll go back into our template and since we named it expenses in the component, we'll rename this to just expenses here in the template. That way this component doesn't care how the expenses are ordered, it simply displays them how it's given them. We also need a template and we will need a controller eventually, but for now we don't need one so I'll just save this as is. Then we'll go into home and we got to make a change here. We got to add our new component here in the template. We'll need to pass in the expenses. Now from the perspective of our home component, what we're actually doing is setting the expense data on this expenseListDisplay component. So I'm going to name this attribute expense-data and that will be equal to our $ctrl.expensesInOrder property and since we're naming the attribute expense-data, I need to go back into the expenseListDisplay component and rename the attribute coming in from expense data to expenses, which is how I want to refer to it inside of my component. I'll save that and of course we need to go down into our index and add this new component to our list of scripts and now we can go back to the browser and refresh our page and we can see that it's still working, we're still displaying our data. So we can see that it's very easy to take some of our functionality and cut it off into its own component. Where beforehand home had that big table in it, now all it's got is this one component. That makes the homepage a lot easier to understand because it does less and also because we're encapsulating this functionality in a subcomponent. The subcomponent itself is extremely straightforward. It doesn't even have a controller right now and the display is just the table and the necessary bindings for it to do its job.

Extending the $firebaseArray
The next feature we want to add to our application is the ability to display the total of all of the expenses up in the header. Now there's a few ways that we could accomplish this task. We could go into our home controller and right at the beginning of the controller, we could sum up all of the expensesInOrder and then display them on the page, but of course whenever any of the expenses changes or if a new expense is added, then we'll have to remember to update our sum. So that's a really error-prone and brittle implementation. Another possibility would be to put a watch on the expensesInOrder. That way we can check whenever the expensesInOrder changes and update it here. This method's a little bit nicer because we don't have to worry about manually updating at every place it changes. Any change that happens to the expensesInOrder will go through this watch and it'll get updated, but it's not really the home controller's job to manage something like this. It would be much nicer if we actually had a component or a service that represented the expenses and we could keep that functionality inside of there. Thankfully AngularFire has just such a feature. I'm going to create a new service in my expenses directory called expenseList. This service is going to encapsulate the functionality of the expense list itself. So I'm going to inject the $firebaseArray and create a new object by extending the $firebaseArray. The $firebaseArray function has an extend function on it. This extend method essentially creates a new class constructor. Just like when we created our $firebaseArray down here in our routing information, we called it as a function passing in a query. This expenseList object I'm creating is going to function exactly the same. If I call this object as a function and pass in a ref, then it will create a new $firebaseArray that will also have some additional functionality that I can specify here inside of this configuration object. Now let's start by just replacing our existing expenses list functionality with this new expenseList and then we'll add the new functionality. I'm going to actually return a function, which receives in a ref, and then from that I'll return a new expenseList, passing in the ref that was given and now in our app.js file, instead of bringing in a $firebaseArray, I'm going to eject an expense list. Remember, the service name is lowercase expenseList to match the name of the service. Even though the variable that I created has an uppercase E, the service name is lowercase E. And then instead of calling the $firebaseArray as a function I'll call this expenseList as a function, passing in this query. Of course we need to go into our index.html file, add this new file to our list of files, save this, go to our app and save that, then we can go back to our browser, refresh, and make sure that everything is still working. Alright so now let's go back to this expenseList object we've created and we're going to give it a new piece of functionality. I'm going to create a function called getTotal that will get the total of the entire list. Inside of this function, I'm going to use Angular's forEach method to loop through every element of the $firebaseArray. The $firebaseArray is contained in a special property, this.$list. This property contains all the data that the $firebaseArray will be created from and the second parameter for forEach is a function which receives a single element from the list, in this case I'll call it rec, and I want to total up the amount for each element. So I'll start off with a total variables initialized to zero, add to that total variable, and then return out that total. Now I'll save that file and I can go into the template for home and up here where I'm showing the expenses I'm going to add another piece to this h1, I'm going to wrap this in a small element, and I'm going to bind this to the $ctrl.expensesInOrder property, which normally would be all of the data, remember we've got our binding in home that brings in the expensesInOrder, but I'm going to call the getTotal function on that $firebaseArray and format it as currency of course and remember this works because in our app.js we created our expensesInOrder as an expense list. So if we save this, go back to the browser and refresh our page, we are now displaying the total amount of all the expenses. This feature's called extending the $firebaseArray and this allows you to add new functionality to a $firebaseArray. You can actually do the same thing with Firebase objects. We didn't have a use case for that, but it works exactly the same as extending a $firebaseArray. Whenever you do create a $firebaseArray, it is okay if you want to extend it by default even if you don't have any additional functionality 'cause then whenever you create a $firebaseArray, instead of returning a $firebaseArray function, you have an object that represents that specific list. That could be helpful because it gives a name to the type of object that you're creating. Rather than just a generic $firebaseArray, when we return an expenseList, it's a little bit more meaningful here in the code. Of course whether you do it by default or wait until you have a need to extend your $firebaseArray is really up to your own preference.

Deleting List Data
The next piece of functionality we'll add is the ability to delete expenses. This is actually a pretty easy piece of functionality to add. It's going to take us more work to make it look nice than it will actually take to make the delete happen. Now before you implement this functionality, since we don't have a way to create new expenses yet, it might be a good idea to go back into your data and from the root, see here we're on the root, we can double check that by making sure the URL doesn't have any subdirectories on it, we can export our data out and that will export it to a JSON file and then after we delete some records, if we want them back in, we can simply click the import button and import that same JSON file back in and that will replace all of our data. So let's start by making a little delete button. We're going to put a little X right over here to the side on each row, but we only want that X to show up when we hover over the row and also when we hover over the X itself we want it to get a little bit bigger. I've already created styles to support all of this, we just need to do a little bit of work in our template. I'll start off by going to our TR tag and we're going to add some new pieces to it. First we'll add a mouseenter event using the ng-mouseenter directive and in this case instead of calling a function we're just going to set a Boolean variable to true. So let's create a new variable called hovering and set it equal to true and what will happen is the scope will now have a hovering variable set to true whenever the mouseenter event fires and then we'll do the same thing with the mouseleave event and on this one we'll set hovering back to false, which would be its default value even when it hasn't been created. And now inside of this last cell here, instead of a space, we're going to create a span and we only want this span to show up when that hovering variable is true so we'll use an ng-show. We'll give it some classes in order to show an appropriate remove icon. I'm just going to use the glyphicons that come with bootstrap to show a little remove icon and now at this point this span will show up and show a little remove icon only when we're hovering over the row, but we also want to expand the icon a little bit and turn it red if the user hovers over this specific span. So if they're getting ready to delete and they hover over the X, we'll make it a little bit more obvious that that's clickable and to do that we'll add another mouseenter and mouseleave event and this time instead of setting hovering to true, we'll set a variable that's specific just to this delete icon, which we'll call delhovering and we'll do the same thing for mouseleave and set it to false and then finally whenever delhovering is set to true, we'll apply a specific class to this span. We'll use the ng-class directive, which lets us say that we want a specific class, which is hover-delete, to be applied to this span only when delhovering is true. And that class is specified down in the styles.css hover-delete. It turns the color to red and also scales up the icon by 30%. So now whenever a user hovers over just that span, it will turn red and zoom in a little bit and of course we need to add our click event so that when they do click, we can delete the expense. So we use an ng-click directive and we'll call the $ctrl.deleteExpense method, which we haven't created yet, passing in the current expense. Then let's close up our span and we're done with our changes to the display. Now we need to go into our controller and first create it and then we'll add the deleteExpense method. That method receives in the expense and in order to delete a specific expense from Firebase, we use AngularFire. Remember this expenses variable is a $firebaseArray and that has a remove method that will allow us to delete data. So we call this .expenses.$remove and pass in the expense we want to delete and that will delete one specific piece of data from a list of data in Firebase. So let's save our file and we'll go back to the browser and refresh and now you can see when we hover that we are seeing the delete icon over to the right and if we go and hover over the delete icon itself, it expands and turns red. And finally if we delete a specific item, it disappears from the list and it actually disappears from within Firebase. We can go in and see that in the expenses we now only have four expenses to match the four expenses that still remain.

Passing Data to Subcomponents
Now that we can delete expenses, let's give ourselves the ability to create new expenses. While doing this, we're going to see a scenario where we have to retrieve some ancillary data and pass it into a subcomponent. On our homepage, we want to create a bunch of input controls down at the bottom of the list that a user can just type in new values right there and click create, but I want this to be its own component. So go back to our code and we'll create a new component underneath expenses. So create two new files, we'll call it the editExpense component and a template for that and while I'm thinking about it I'll go down to the index and add that to the list of files I'm getting and let's start in our template. We're going to need a form and I want it to be an inline form using bootstrap's form-inline class, It doesn't need an action so I'll take that off, and then I need some input controls. I'll need first one for the data and give it a placeholder, the ng-model, and a class of form-control, which will make it look nice, and I'll duplicate that and we'll need an input also for payee and for description. So we'll just change our placeholder to payee and the field name as well and this will go to description and the field name as well. Next I need the category and I'll want a select control for that. We'll give that an ng-model set to $ctrl.selectedCategory. This doesn't exist right now, this will be a new variable on our controller that will just hold what the currently selected category is. And we use our ng-options to fill that in and here we'll specify category.name for category, which tells the ng-options to display the name of each category and that will be in our controller and now we realize we don't have the categories yet in our expense, we're going to have to bring them in and we'll just name them categories and we also want to add a track by option. So we're going to track by the category's ID property and that's $id, this is a special property built into Firebase, which is the key of the node. So if we go back and look at our Firebase data and look at a specific category, the ID for books is five As, the ID for travel expenses is this long string starting with a dash. That gives us our ng-options, we also want to give that a class of form-control and finally we need another input box. This is going to be for our mount. To finish this up, we need a button to save when a user puts in new values. I'll give it some bootstrap classes. And the text will be create and of course we need a click event, we'll just call it create method on our controller, and that should be good enough for now. So there's a few things we need to do. We need to bring in the category data and we also need to make the create method on our controller. Next we'll create our component. It's going to need a template of course. And we know we need the category data so we'll create a binding for that and we'll also create our controller. Next we want to add this component to our homepage. So I'll save that, go into the home's template and after the expense-list-display, I'll add the edit-expense component and now remember the edit-expense component needs categories so we're going to have to specify categories when we create the component. In order to pass those categories in, the home component's going to need the categories. So we'll go into our app.js file and we'll add categories as data that's going to come into the home component. We're already getting the expensesInOrder, so just going to copy this and paste it in here and we'll gather the categories instead of the expenses. We don't need the expenseList, instead we want to bring in a $firebaseArray and that's the method we'll use and we're not going to call our getExpensesRef, we're going to call getCategoriesRef, we used this previously on the categories page, and we're going to order by name so it's in alphabetical order and that's good as is. We also need to add the categories to our template, which is going to make our template a little bit long here. But we'll say categories=$resolve.categories and now we can go into our homepage and we can add a binding for categories, which will bring the categories into the homepage and then in the home's template page we can simply specify $ctrl.categories and that will pass the categories from the route's resolve method into the home component and from the home component into the edit expense component and now we can save our work and go to the browser and preview what we've done so far and you can see our controls are all in, but we have one problem, the category drop-down doesn't have a selected value. It would be nice to select a default value there so that it's not even valid to select no value at all. Therefore let's make the component automatically select the first category. We'll go back into our code and go into our editExpense.js and we're going to add a setDefaults method and we'll just set defaults for every control. We'll use this later on. So we'll set this .amount equal to a link string and we'll do the same thing for description, payee. We'll default the date to a new date, set to March 3rd, 1985, a fantastic year to be involved in computers, and we'll set this toLocaleDateString so that it's formatted nice and then finally we'll set our selectedCategory and we'll just set it equal to the first value inside the categories array and afterwards we'll immediately call this function, go back to our browser and refresh, and we now have selected the first category. In the next section we'll actually hook up the create button. Now that we can delete expenses, let's give ourselves the ability to create new expenses. While doing this, we're going to see a scenario where we have to retrieve some ancillary data and pass it into a subcomponent. On our homepage, we want to create a bunch of input controls down at the bottom of the list that a user can just type in new values right there and click create, but I want this to be its own component. So go back to our code and we'll create a new component underneath expenses. So create two new files, we'll call it the editExpense component and a template for that and while I'm thinking about it I'll go down to the index and add that to the list of files I'm getting and let's start in our template. We're going to need a form and I want it to be an inline form using boostrap's form-inline class, it doesn't need an action so I'll take that off, and then I need some input controls. I'll need first one for the date and give it a placeholder, the ng-model, and a class of form-control, which will make it look nice, and I'll duplicate that and we'll need an input also for payee and for description. So we'll just change our placeholder to payee and the field name as well and this will go to description and the field name as well. Next I need the category and I want to select control for that. We'll give that an ng-model set to $ctrl.selectedCategory. This doesn't exist right now, this will be a new variable on our controller that will just hold what the currently selected category is. And we'll use our ng-options to fill that in and here we'll specify category.name for category, which tells the ng-options to display the name of each category and that will be in our controller and now we realize we don't have the categories yet in our expense, we're going to have to bring them in and we'll just name them categories and we also want to add a track by option. So we're going to track by the category's ID property and that's $id, this is a special property built in to Firebase, which is the key of the node. So if we go back and look at our Firebase data and look at a specific category, the ID for books is five As, the ID for travel expenses is this long string starting with a dash. That gives us our ng-options, we also want to give that a class of form-control and finally we need another input box, this is going to be for our amount. To finish this up, we need a button to save when a user puts in new values, I'll give it some bootstrap classes, and the text will be create and of course we need a click event and we'll just call it create method on our controller and that should be good enough for now. So there's a few things we need to do, we need to bring in the category data and we also need to make the create method on our controller. Next we'll create our component. It's going to need a template of course. And we know we need the category data so we'll create a binding for that and we'll also create our controller. Next we want to add this component to our homepage. So I'll save that, go into the home's template and after the expense-list-display, I'll add the edit-expense component and now remember the edit-expense component needs categories so we're going to have to specify categories when we create the component. In order to pass those categories in, the home component's going to need the categories. So we'll go into our app.js file and we'll add categories as data that's going to come into the home component. We're already getting the expensesInOrder so we're just going to copy this and paste it in here and we'll gather the categories instead of the expenses. We don't need the expense list. Instead we want to bring in a $firebaseArray and that's the method we'll use and we're not going to call our getExpensesRef, we're going to call getCategoriesRef, we used this previously on the categories page, and we're going to order by name so it's in alphabetical order and that's good as is. We also need to add the categories to our template, which is going to make our template a little bit long here. But we'll say categories=$resolve.categories and now we can go into our homepage and we could add a binding for categories, which will bring the categories into the homepage and then in the home's template page, we can simply specify $ctrl.categories and that will pass the categories from the route's resolve method into the home component and from the home component into the editExpense component and now we can save our work and go to the browser and preview what we've done so far and you can see our controls are all in, but we have one problem, the category drop-down doesn't have a selected value. It would be nice to select a default value there so that it's not even valid to select no value at all. Therefore, let's make the component automatically select the first category. We'll go back into our code and go into our editExpense.js and we're going to add a setDefaults method and we'll just set defaults for every control. We'll use this later on. So we'll set this .amount equal to a link string and we'll do the same thing for description, payee. We'll default the date to a new date, set to March 3rd, 1985, a fantastic year to be involved in computers, and we'll set this toLocaleDateString so that it's formatted nice and then finally we'll set our selectedCategory and we'll just set it equal to the first value inside the categories array and afterwards we'll immediately call this function, go back to our browser and refresh and we now have selected the first category. In the next section we'll actually hook up the create button.

Creating Expenses
Now that we've got our categories coming in and our pages set up, let's go ahead and finish implementing the create functionality. In our template we named the method create. So we'll go into our controller and make that method. This method needs to gather up the data that the user has input and then save it to our $firebaseArray. So let's first create a new object, which will represent the new expense. We'll call it expenseData. The amount will be set by calling parseFloat and passing in the amount field. Description will be just set to this.desc, payee is again very easy. Next we have the category. This one is a little bit trickier. Remember, in our data our category's actually a complex object. If we look at an expense, we can see that category is an object that has both an ID and a name. So we'll create an object, its name will be set to this.selectedCategory.name and its ID will be set to this.selectedCategory again .$id. This is quite convenient since our selected category not only has its name, but its ID property as well. Finally we've got date, which we'll set to a new date object passing in this.date and so long as the format that the user types in is correct, then it'll be fine and then we will call the toJSON method. Of course in a real application, we'd do some validation, making sure that the amount and date format were correct, but for the purposes of this simple demo app we'll skip that since the important part is how AngularFire works and not so much the validation. Now that we've got the data gathered up into this.expenseData object, we need to clear out the fields that the user's typed into so we'll call setDefaults again and then finally we're going to do the magic, which is to save the data. I'm just putting in a comment for now because the way that we create data on a $firebaseArray is to actually take the $firebaseArray object and call its add method, but we have one problem, we don't have the $firebaseArray obeject for the expenses in this component. So we have a couple of options. We can either pass in that $firebaseArray as well through a binding or we can raise an event and a higher level component can actually implement the create functionality and that's how we're going to implement this, by raising an event. So I'm just going to go ahead and name that event, it's going to be called this.createNewExpense, and I need to pass in the expenseData as a parameter. But we'll have to format this call a little differently. Let's look at why that is. This.createNewExpense method is going to be on our bindings and it's set to an ampersand. If you haven't dealt with this before, this is a way for a lower level component to raise an event to a higher level component that the higher level component can listen to. Because of this, I can now go into my home.html page and here on the editExpense component I can listen to this create-new-expense event. Of course I've got to use snake case or dash case, not camelCase, because this is an attribute name. And now I can define a function that will get called whenever this event gets raised. So I'll call this new function $ctrl.createExpense and it's going to receive a parameter, which I'll call expenseData. Now here where I'm passing in expenseData, there is no object named expenseData. Nowhere inside of this template is there an object named expenseData. I'm also not defining this function here, I'm actually invoking it. So I'm calling the function with a parameter that doesn't exist. Again, expenseData does not exist. For now it's just a placeholder. But I can take advantage of this by going back into my controller for my editExpense component and I can override the expenseData parameter when I call createNewExpense by creating an object and setting a property named expenseData to whatever I want it to be. This method, when called, because it's called with an object that has a property that matches the name of the parameter given on the function evocation here, is going to override that parameter with the value I give it here. So therefore, this.expenseData, which is the expenseData property on the controller of the editExpense component, is going to become the value of the expenseData parameter on this function, but I must specify it here, I cannot leave it blank, I've got to have the value specified here. Then inside of my home.js file, I need to create the controller and I'll create a new method called this.createExpense, which matches the method that I'm calling over here, the createExpense method, and of course in the definition of the function I've got to have the same parameter and from here I can now take the expenseData parameter that I'm receiving and save it to the $firebaseArray by calling this.expensesInOrder.$add, which is the name of the function. We've already seen this once before when we did our categories and we passed in the new data. Now it's important to note the value that comes in here is not the same thing that we're passing in to the function here in editExpense. Here we're passing in an object that has an expenseData property. Because of the way that Angular handles overriding the parameters, it's going to unwrap this object and pass in just the value of that expenseData property. So this expenseData parameter here, which is exactly what we want, it'll just be the data that we're going to be adding to our Firebase. And with that we can go ahead and save all of our files, go back to the browser, refresh the page, and let's put in some data. We'll put back in that book that we had before and then we'll click create and the data has been added to our Firebase. So even with more complex data, it's still very simple to add it to Firebase, we just have to call the $add method on our $firebaseArray.

Selecting Data for Edit
In this section we're going to begin implementing our last piece of functionality, which will be editing data. This functionality has two aspects to it. First we need to be able to select an expense for editing and then we need to be able to save the data once we've made changes. So we'll start by giving ourselves the ability to select an expense, which we'll implement as a row click. Whenever we click on a row, that will select an expense for editing. Back to our code. We'll start in the expenseListDisplay's template where we need to put an ng-click on our row. And we'll call the method named $ctrl.clickRow, passing in the current expense and we'll save that, then we go to our controller for the expenseListDisplay and we'll implement that method. Now once we've clicked on a row we want the data for that row to appear inside of our input boxes down at the bottom, but our expenseListDisplay component is not the same component as our editExpense component. So we need the two to communicate. We need this component to let somebody know that the expense has been selected and then the editExpense can actually display the selected data. So again, we'll raise an event. We'll start off by going up to our bindings and we'll create a new event called selectExpense, giving it the ampersand, and then from inside of our clickRow function, we'll call this.selectExpense and we're going to pass in the current expense, but we need to do the same thing that we did in the previous section by overriding the parameter that it's expecting. So we're going to create an object with a property of expense and set it to the expense that is the parameter to this function. And with that done we'll go to the template for the homepage, an event listener on the expenseListDisplay and again that event is called selectExpense. So here it'll be select-expense and our listener will be a method on our controller named editExpense, passing in an expense object, and again we are overriding this expense object by putting it inside of an object with a property of expense and specifying in here what we want the value to be rather than allowing the template to specify what we want that value to be. Notice the difference in the names of the events. In the expenseListDisplay, we're raising a selectExpense event. As far as the list display is concerned, all we're doing is selecting one of our expenses. But to the homepage when an expense is selected, we want to actually edit that expense. So we'll go into the controller for home and implement that method and it receives a parameter named expense and I'll set a property on this controller named this.editedExpense and set it equal to the expense parameter. Now at this point, we've got the expense selected and we've notified the home component and in the next section we'll pass that expense to our editExpense component so that it can display and allow us to edit the data. So to review what we've done, we went into our expenseList template and added a click event so that we can select a row. Within our expenseListDisplay component, we raised that event, which we named selectExpense, and passed it the expense that corresponded to the row that was clicked and then within our home component we listened to that event and called our editExpense method, which then stored the expense in a variable named editedExpense.

Editing List Data
Now that we have our expense in this editedExpense property on the controller for the home component, we want to pass that into our editExpense component. So what we want here is a new binding where we can receive the expense that's going to be edited. So we'll call this editedExpense and that will be a two-way binding. Now in order to pass that edited expense in, we have to go to the template for the homepage and on the editExpense component we're going to add that edited-expense. So that's a new attribute named edited-expense. And we'll set that equal to the property that we created right here on line 14, editedExpense. So in our template, that will be $ctrl.editedExpense. Now that we're setting the editedExpense in the editExpense component, we need to do something about that. Here we've got this two-way binding to editedExpense, but we need to be notified that editedExpense has been set to a value. When a child component talks to a parent component, it can raise an event and the parent component can be notified that something happened. When a parent component talks down to a child component, it does so through two-way binding. So the child component is not listening to an event on the parent component. Now we can work around this by using Angular's built-in event bus, but that's generally not a good thing to do if we can avoid it. Instead what we can do is put a watch on this editedExpense and we can detect if it's got a value and if it does then we can display the data for the editedExpense inside the controls on our editExpense component. So let's implement that. We'll come down here and we need to call scope.watch, but we don't even have scope in our controller. Again, generally we don't have them in the controller for a component. So we'll have to add it and then we can call scope.watch and now we want to watch the editedExpense, but we don't just type in editedExpense because that would look for a property named editedExpense on the scope, but our editedExpense is going to be on our controller. So instead we'll have to give it the name of our controller, which is $ctrl, then a period and then editedExpense and then a function as a call back for when this value does change and the first parameter it receives is new data and inside this function we will test to see if new data is set to a value by calling not not on newData and if it does have a value, then we want to set our input fields to the value of this data. So we'll set this.amount=newData.amount, do that with description. We'll want to set the date, but remember the date's in a JSON format so we'll create a date variable and pass in the newData.date and then we can set this.date equal to date.toLocaleDateString and then we want to set the category so we'll set this.selectedCategory to be equal to and now we have to look up the category that this expense has. We know that newData.category.id is the ID of the category for this expense. So we can use that knowledge to look it up in our categories list. So we will say this.categories at a specific index and now we'll take advantage of one of the functions that AngularFire puts on it's $firebaseArrays, which is the $indexFor method where we pass in an ID and we'll get out the index for that ID And I'm just going to format this a little by putting it on another line and closing this up. Now it's important to understand that the ID property, if we go and look at our data, is set to the key value of the category. So for this category, computer equipment, the ID is set to five Bs and that is the key of the category that matches computer equipment. So this indexFor method takes in the key that you're looking for and it will return out to you the index of the matching record. So we're passing in that ID and it gives us back the record who has that matching key. And finally we set payee to newData.payee. Now of course we're inside anonymous functions, we need to bind it to this and now if we save all of our work, then we can go back to the browser, refresh our page, and if we select one of our expenses, then it should show up inside of our input boxes. And you'll notice that everything but the description is showing up properly. We go back and that is because the name of the property on newData is actually description and not desc. This is a good example of having property names that are different, description here and desc here end up causing us problems. So let's save that, go back to the browser and refresh and we'll select one and now we've got the data set correctly. Now we just need to implement our save functionality, but right now all we've got is a create button and we don't want a create button, we want a save button and probably a cancel button. So let's go back into our template and we'll add two new buttons, save and cancel, and we'll make cancel, instead of being primary, we'll make it a warning so it has a different color and then we'll call save in this case and cancel in this case and we don't want all three events to show up all the time. So what we need is to know whether we're in an editing state or a non-editing state. We can figure that out by going back to our controller and if we do have a new set of data, then let's set a new property on our controller called this.editing and we'll set it to true and then back in our template we can add some ng-show directives to each of these buttons and this one will only show if we're not editing and this one will show if we are and this one will show if we are. So let's save that and we'll go back to our controller and implement the save and cancel methods. Save will be a matter of transferring the data from the input boxes onto the editedExpense that was brought in. So we'll have to set this.editedExpense.amount equal to parseFloat of this.amount and we'll do the same thing for description, except we don't need to parseFloat on that, and let's get the property names right and payee is this.payee, date will be a new date where we take this.date and pass it into the constructor and call toJSON on it. The category, remember, is an object with two properties, a name and an ID. And in this case since we're dealing with the firebase category, it doesn't have an ID property, its key is under the $id property. Then we'll need to save the data and after that we can set our defaults so that the controls go back to blank. Let's turn editing off and we'll also set the edtedExpense back to null. Because we'll be done editing, we don't want that value to be set anymore. And before we figure out how we're going to do this save data, let's also implement the cancel function. And inside of here, we'll just do the same things we did at the end of our save method. So I'll paste those in. We are copying a little bit of code so it might be a good idea to put these into their own sub procedure and call that. I'm just going to leave them duplicated for now. So let's talk about how we save this data. Just like when we're creating or deleting data, we'll need the $firebaseArray to call a method on it, but we don't have access to it inside the editExpense controller. So we'll need to raise another event that the home component can listen to. So let's name that updateExpense and we'll go up here into our bindings and add a new binding, updateExpense. The child component essentially raising an event. We'll save that and go into the template for our home and on the editExpense we will add that updateExpense event and when it's raised we will call our $ctrl.updateExpense. Save that and go into the controller for the homepage and we'll implement that method and here we have access to the $firebaseArray, which is this.expensesInOrder, and we call the $save method and pass in the expense that we want to update. In this case, it doesn't need to come in on a parameter because we have the editedExpense property and that's the one we want to save. That's why in this case, unlike previous cases, we don't have to override the event when we call it. So when we call updateExpense, we're not passing in any parameter at all and when it gets up to the home controller, there's no parameter and we simply call save and pass in our reference, which is editedExpense. And now we can go out to the browser, refresh, and let's select a row and let's change the price to 2.98 and save and you can see it's updated the price. So our functionality's working.

Updating to 1.2
Now we're going to see how to take advantage of the new features in AngularFire 1.2. There are two new services in 1.2 that we can take advantage of. They both have to do with connecting to our Firebase. The first one is a firebaseRef service and the second one is a firebaseAuth service. We'll first look at how to use the new Firebase ref service. I'm starting here in my fbUrl file. This is where we store our URL to our Firebase and to create our root ref. I'm going to comment out both of these lines of code and instead what we're going to do is we're going to create a config section for our module. So we do angular.module, grabbing our module, and we call the config method and now I'm going to pass in a function and I want this new Firebase ref service, but in a config we have to add the suffix provider. So it's firebaseRefProvider. And I'm going to configure that provider with the URL to my Firebase. So it's firebaseRefProvider.registerUrl and the URL to my Firebase. So I'll go up here and copy that. And paste it in here. Now I can register more than one URL, but they all have to be pointing at the same Firebase. They can't point at multiple different Firebases and that allows us to easily get a ref to not only the root of our Firebase, but also to other paths in our Firebase. But there's a big problem and that is that during the config phase of a module, we don't have access to the logged in user, who they are and what their user ID is. So here in our fbRef where we can actually get the UID for the logged in user and make that part of the path. We can't do that when we're configuring the firebaseRef service. So I'm just going to configure only a pointer to the root of my Firebase. And with that in place, I can save this. The next thing I'll do is go into my auth service and I no longer need the auth service at all. Once I configure the firebaseRef, there's a different service, the firebaseAuthService, and by that I don't mean this firebaseAuth service, the name is actually firebaseAuthService like that. And that new service will now replace everything that I've done here. So I can actually comment all of this code out. We won't need our own auth service anymore. I'll save that and with that done we can go into our fbRef service and we'll have to make some changes here. We no longer have our own auth service, instead we're going to bring in the firebaseAuthService, and again that has the word service as part of it, and also that new firebaseRef service. We've configured this firebaseRef service here in fbUrl where we called the registerUrl function on it. Now, this service will be a ref to my Firebase. So I'm going to make some changes by using this instead of rootRef and then in every case I have to call .default, which is the actual ref to the root of my Firebase. If I were to configure multiple refs here in the registerUrl function, then I could access those at this point, but I'm just going to access the default one and then from there the child method gives me a pointer to the correct location. And the other thing we need to do is replace the auth service that we were using before with our new firebaseAuthService. And these lines of code are getting a little bit long so let's wrap them. And we finished the changes to the fbRef service and the last thing we need to do is go into our app file where we've configured all of our routes and this needs to change in here. We no longer have an auth service. So we'll replace that with the firebaseAuthService and we'll do that everywhere that we are using auth. And we've got it here as well and down here. And lastly, right here. And now with all those changes, we can go back to our browser and we can refresh and our application is still working. We can edit data. We can see our preferences and change those. We can look at categories. Everything is working. So those are the new features in Angular 1.2. One of the things that I think is very interesting about this is the code that we wrote before versus the code with the new services really is not that much different. The one place where I think the code is a little bit better is right here. Instead of getting cute with the service method, we don't have to do that anymore, we can just register our URL. But otherwise the code is pretty much as readable before as it was after. So whether you want to use these new services or not is up to you, but now you do know how to use them.

Summary
In this module we really learned a lot. We learned how to display lists of data in Angular using Firebase, which is a little bit more complex than you think because of how Firebase internally stores objects, but with the $firebaseArray object all those details are hidden from us so it's simple and easy to deal with lists of data in Angular. We also learned how to create, edit, and delete data, then we learned about a really cool piece of functionality where we can extend the $firebaseArray to add our own functions to our lists of data. The $firebaseArray is likely the most common AngularFire object you will use in your app since lists of data are so common. So it really benefits you to learn how to work with it well. And finally, we saw the new pieces in AngularFire 1.2. They weren't significant changes and our code looked pretty similar before, but there's no reason not to use these new service going forward.

Course Summary
Thank you for watching this course on building applications with Angular, Firebase, and AngularFire. I really enjoyed putting this course together. As a longtime Angular developer, I definitely have found renewed enjoyment of Angular when using it with Firebase. It just makes data access so slick and easy. I really think that Firebase is a great technology and everybody can benefit from learning it and using it. If you have any questions, please post them to the course discussion board, I check it frequently, and if you want to say Hi, hit me up on Twitter or connect with me on LinkedIn.

Course author
	
Joe Eames
Joe has been a web developer for the last 13 of his 16+ years as a professional developer. He has specialized in front end and middle tier development . Although his greatest love is writing...

Course info
LevelIntermediate
Rating
(42)
My rating
Duration2h 37m
Released6 Apr 2016
Share course
